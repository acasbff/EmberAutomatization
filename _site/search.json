[
  {
    "objectID": "energy_generation_yoy_waterfall.html",
    "href": "energy_generation_yoy_waterfall.html",
    "title": "Import packages",
    "section": "",
    "text": "Code\nimport requests\nimport pandas as pd\nimport os\nimport time\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom datetime import datetime"
  },
  {
    "objectID": "energy_generation_yoy_waterfall.html#set-the-quarter-and-adjust-waterfall-settings-if-needed",
    "href": "energy_generation_yoy_waterfall.html#set-the-quarter-and-adjust-waterfall-settings-if-needed",
    "title": "Import packages",
    "section": "Set the quarter and adjust waterfall settings if needed",
    "text": "Set the quarter and adjust waterfall settings if needed\n\n\nCode\nlast_month = 6\nlast_year = 2024\n\nnbr_months_waterfall = 3\n\n# Output file name\noutputfile = \"Waterfall_ElectricityGeneration_20232024Q2_Python\"\n\n# Define which categories should have labels outside, edit in case other fuels need label adjustments\noutside_labels = ['Nuclear', 'Other']\n\n# Define y-axis limits and ticks\ny_min, y_max = -50, 30  # Adjusted to go a bit above and below the ticks\ny_ticks = np.arange(-50, 26, 25)"
  },
  {
    "objectID": "energy_generation_yoy_waterfall.html#api-access-parameters",
    "href": "energy_generation_yoy_waterfall.html#api-access-parameters",
    "title": "Import packages",
    "section": "API access parameters",
    "text": "API access parameters\n\n\nCode\nmy_api_key = \"51356ef8-f7dd-43a1-9629-1965b7830a26\"\nbase_url = \"https://api.ember-climate.org\""
  },
  {
    "objectID": "energy_generation_yoy_waterfall.html#parameters-for-the-charts",
    "href": "energy_generation_yoy_waterfall.html#parameters-for-the-charts",
    "title": "Import packages",
    "section": "Parameters for the charts",
    "text": "Parameters for the charts\n\nCountries to import\n\n\nCode\niso_codes = [\n    \"ALB\",  # Albania\n    \"AUT\",  # Austria\n    \"BEL\",  # Belgium\n    \"BIH\",  # Bosnia and Herzegovina\n    \"BGR\",  # Bulgaria\n    \"HRV\",  # Croatia\n    \"CYP\",  # Cyprus\n    \"CZE\",  # Czech Republic\n    \"DNK\",  # Denmark\n    \"EST\",  # Estonia\n    \"FIN\",  # Finland\n    \"FRA\",  # France\n    \"DEU\",  # Germany\n    \"GRC\",  # Greece\n    \"HUN\",  # Hungary\n    \"IRL\",  # Ireland\n    \"ITA\",  # Italy\n    \"XKX\",  # Kosovo\n    \"LVA\",  # Latvia\n    \"LTU\",  # Lithuania\n    \"LUX\",  # Luxembourg\n    \"MLT\",  # Malta\n    \"MDA\",  # Moldova\n    \"MNE\",  # Montenegro\n    \"NLD\",  # Netherlands\n    \"MKD\",  # North Macedonia\n    \"NOR\",  # Norway\n    \"POL\",  # Poland\n    \"PRT\",  # Portugal\n    \"ROU\",  # Romania\n    \"SRB\",  # Serbia\n    \"SVK\",  # Slovakia\n    \"SVN\",  # Slovenia\n    \"ESP\",  # Spain\n    \"SWE\",  # Sweden\n    \"CHE\",  # Switzerland\n    \"TUR\",  # Turkey\n    \"GBR\",  # United Kingdom\n]\n\n\n\nListing the months we will have, based on the parameters we have chosen\n\n\nCode\nmonths_old_waterfall = [\n    f\"{year}-{month:02d}-01\"\n    for year, month in [\n        time.localtime(\n            time.mktime((last_year - 1, last_month - n, 1, 0, 0, 0, 0, 0, 0))\n        )[:2]\n        for n in range(nbr_months_waterfall)\n    ]\n]\nmonths_new_waterfall = [\n    f\"{year}-{month:02d}-01\"\n    for year, month in [\n        time.localtime(\n            time.mktime((last_year, last_month  - n, 1, 0, 0, 0, 0, 0, 0))\n        )[:2]\n        for n in range(nbr_months_waterfall)\n    ]\n]\nmonths_expected = [\n    f\"{month:02d}\"\n    for year, month in [\n        time.localtime(\n            time.mktime((last_year, last_month  - n, 1, 0, 0, 0, 0, 0, 0))\n        )[:2]\n        for n in range(nbr_months_waterfall)\n    ]\n]\n\n\n\n\nCode\nmonths_old_waterfall\n\n\n\n\nCode\nmonths_new_waterfall"
  },
  {
    "objectID": "energy_generation_yoy_waterfall.html#running-the-api",
    "href": "energy_generation_yoy_waterfall.html#running-the-api",
    "title": "Import packages",
    "section": "Running the API",
    "text": "Running the API\n\nQueries\n\n\nCode\nquery_url_generation = (\n    f\"{base_url}/v1/electricity-generation/monthly\"\n    + f\"?entity_code={','.join(iso_codes)}&is_aggregate_series=false&start_date=2000&api_key={my_api_key}\"\n)\n\nquery_url_demand = (\n    f\"{base_url}/v1/electricity-demand/monthly\"\n    + f\"?entity_code={','.join(iso_codes)}&is_aggregate_series=false&start_date=2000&api_key={my_api_key}\"\n)\n\n\n\n\nCode\nquery_url_generation\n\n\n\n\nCode\nquery_url_demand\n\n\n\n\nExecuting the queries. 200 = success\n\n\nCode\nresponse_generation = requests.get(query_url_generation)\nresponse_demand = requests.get(query_url_demand)\n\n\n\n\nCode\nresponse_generation.status_code\n\n\n\n\nCode\nresponse_demand.status_code"
  },
  {
    "objectID": "energy_generation_yoy_waterfall.html#extracting-the-results",
    "href": "energy_generation_yoy_waterfall.html#extracting-the-results",
    "title": "Import packages",
    "section": "Extracting the results",
    "text": "Extracting the results\n\n\nCode\ndata_generation = response_generation.json()[\"data\"]\ndata_demand = response_demand.json()[\"data\"]\ndf_generation = pd.DataFrame(data_generation)\ndf_demand = pd.DataFrame(data_demand)\n\n\n\n\nCode\ndf_generation\n\n\n\n\nCode\ndf_demand\n\n\n\nFiltering only the data that we need\n\nWe extract the month from the date\n\n\nCode\ndf_generation[\"month\"] = df_generation[\"date\"].str[5:7]\ndf_demand[\"month\"] = df_demand[\"date\"].str[5:7]\n\n\n\n\nWe create one table with the current (‘new’) data, one table with the data we compare with (‘old’)\n\n\nCode\ndf_generation_old = df_generation.loc[\n        df_generation[\"date\"].isin(months_old_waterfall)\n    ].copy()\ndf_generation_old[\"generation_twh_old\"] = df_generation_old[\"generation_twh\"]\ndf_generation_old = df_generation_old[\n        [\"entity\", \"entity_code\", \"month\", \"series\", \"generation_twh_old\"]\n    ]\ndf_generation_new = df_generation.loc[\n        df_generation[\"date\"].isin(months_new_waterfall)\n    ].copy()\ndf_generation_new[\"generation_twh_new\"] = df_generation_new[\"generation_twh\"]\ndf_generation_new = df_generation_new[\n        [\"entity\", \"entity_code\", \"month\", \"series\", \"generation_twh_new\", \"date\"]\n    ]\n\n\n\n\nCode\ndf_demand_old = df_demand.loc[df_demand[\"date\"].isin(months_old_waterfall)].copy()\ndf_demand_old[\"series\"] = \"Demand\"\ndf_demand_old[\"generation_twh_old\"] = df_demand_old[\"demand_twh\"]\ndf_demand_old = df_demand_old[\n        [\"entity\", \"entity_code\", \"month\", \"series\", \"generation_twh_old\"]\n    ]\n\ndf_demand_new = df_demand.loc[df_demand[\"date\"].isin(months_new_waterfall)].copy()\ndf_demand_new[\"series\"] = \"Demand\"\ndf_demand_new[\"generation_twh_new\"] = df_demand_new[\"demand_twh\"]\ndf_demand_new = df_demand_new[\n        [\"entity\", \"entity_code\", \"month\", \"series\", \"generation_twh_new\", \"date\"]\n    ]\n\n\n\n\nWe merge generation and demand tables\n\n\nCode\ndf_old = pd.concat([df_generation_old, df_demand_old])\ndf_new = pd.concat([df_generation_new, df_demand_new])\n\n\n\n\nWe merge the ‘old’ and ‘new’\n\n\nCode\ndf_all = pd.merge(\n        df_old, df_new, how=\"outer\", on=[\"entity\", \"entity_code\", \"series\", \"month\"]\n    )\n\n\n\n\nWe rename some categories\n\n\nCode\ndf_all[\"series\"] = df_all[\"series\"].apply(\n        lambda x: (\n            \"Other\"\n            if x in [\"Bioenergy\", \"Net imports\", \"Other renewables\", \"Other fossil\"]\n            else x\n        )\n    )\ndf_all = df_all.fillna(0)\n\n\n\n\n\nData checks\n\n\nCode\ncombinations = [(x, y) for x in iso_codes for y in months_expected]\nexpected_outcome = pd.DataFrame(combinations, columns=['entity_code', 'month'])\n\n\n\nMissing countries in generation - Old\n\n\nCode\ndf_generation_old_check = df_generation_old[df_generation_old.generation_twh_old &gt; 0]\ndf_generation_old_check = df_generation_old_check[['entity_code','month']].drop_duplicates()\n\nexpected_outcome[~expected_outcome.set_index(['entity_code','month']).index.isin(df_generation_old_check.set_index(['entity_code','month']).index)]\n\n\n\n\nMissing countries in demand - Old\n\n\nCode\ndf_demand_old_check = df_demand_old[df_demand_old.generation_twh_old &gt; 0]\ndf_demand_old_check = df_demand_old_check[['entity_code','month']].drop_duplicates()\n\nexpected_outcome[~expected_outcome.set_index(['entity_code','month']).index.isin(df_demand_old_check.set_index(['entity_code','month']).index)]\n\n\n\n\nMissing countries in generation - New\n\n\nCode\ndf_demand_new_check = df_demand_new[df_demand_new.generation_twh_new &gt; 0]\ndf_demand_new_check = df_demand_new_check[['entity_code','month']].drop_duplicates()\n\nexpected_outcome[~expected_outcome.set_index(['entity_code','month']).index.isin(df_demand_new_check.set_index(['entity_code','month']).index)]\n\n\n\n\nMissing countries in demand - New\n\n\nCode\ndf_generation_new_check = df_generation_new[df_generation_new.generation_twh_new &gt; 0]\ndf_generation_new_check = df_generation_new_check[['entity_code','month']].drop_duplicates()\n\nexpected_outcome[~expected_outcome.set_index(['entity_code','month']).index.isin(df_generation_new_check.set_index(['entity_code','month']).index)]\n\n\n\n\n\nFinal data extraction\n\nWe extract what we need\n\n\nCode\noutput_waterfall = (\n        df_all.loc[df_all[\"date\"].isin(months_new_waterfall)][\n            [\"series\", \"generation_twh_old\", \"generation_twh_new\"]\n        ]\n        .groupby([\"series\"])\n        .sum()\n        .reset_index()\n    )\noutput_waterfall[\"y-o-y change\"] = (\n        output_waterfall[\"generation_twh_new\"] - output_waterfall[\"generation_twh_old\"]\n    )\n\n\n\n\nCode\ncwd = os.getcwd()\nexcel_path_waterfall = os.path.join(cwd,\"data_waterfall.xlsx\")\noutput_waterfall.to_excel(excel_path_waterfall, index=False)\n\n\n\n\nCode\noutput_waterfall"
  },
  {
    "objectID": "energy_generation_yoy_waterfall.html#define-source-data-labels-and-colors",
    "href": "energy_generation_yoy_waterfall.html#define-source-data-labels-and-colors",
    "title": "Import packages",
    "section": "Define source data, labels and colors",
    "text": "Define source data, labels and colors\n\n\nCode\nplt.close('all')\nmatplotlib.use('Agg')\nplt.rcParams['pdf.fonttype'] = 42\nplt.rcParams['text.usetex'] = False\n#plt.rcParams['font.family'] = 'Open Sans'  # Or 'Montserrat'\n\n\n\n\nCode\n# Load the data\ndata = output_waterfall\n\n# Define quarter title, subtitle and axis title label\nold_from = datetime.strptime(months_old_waterfall[-1], '%Y-%m-%d').strftime('%B %Y')\nold_to = datetime.strptime(months_old_waterfall[0], '%Y-%m-%d').strftime('%B %Y')\nnew_from = datetime.strptime(months_new_waterfall[-1], '%Y-%m-%d').strftime('%B %Y')\nnew_to = datetime.strptime(months_new_waterfall[0], '%Y-%m-%d').strftime('%B %Y')\ntitle = \"EUROPE: year-on-year change in electricity generation by fuel in the last quarter\"\nmonths_old_waterfall\nsubtitle = f\"{old_from} - {old_to} versus {new_from} - {new_to}\"\nmonth_from = datetime.strptime(months_new_waterfall[-1], '%Y-%m-%d').strftime('%B')\nmonth_to = datetime.strptime(months_new_waterfall[0], '%Y-%m-%d').strftime('%B')\nquarter = f\"{month_from}-{month_to}\""
  },
  {
    "objectID": "energy_generation_yoy_waterfall.html#chart",
    "href": "energy_generation_yoy_waterfall.html#chart",
    "title": "Import packages",
    "section": "Chart",
    "text": "Chart\n\n\nCode\n# Define the order you want\norder = [\"Coal\", \"Gas\", \"Nuclear\", \"Hydro\", \"Solar\", \"Wind\", \"Other\", \"Demand\"]\ncolors = [\"#475865\", \"#8B969F\", \"#FFA401\", \"#76C8F1\", \"#FEC814\", \"#1FDA4B\", \"#98C4D1\", \"#E0187B\"]\n\n# Ensure 'series' is treated as a categorical type with the defined order\ndata['series'] = pd.Categorical(data['series'], categories=order, ordered=True)\n\n# Sort the DataFrame based on the categorical order and reset the index\ndata = data.sort_values('series').reset_index(drop=True)\n\n# Define the correct colors\n\ndata['Color'] = colors[:len(data)]\n\n# Calculate the cumulative sum for positioning each bar\ndata['Cumulative'] = data['y-o-y change'].cumsum()\ndata['Position'] = data['Cumulative'] - data['y-o-y change']\n\n# Manually adjust the 'Position' and 'Cumulative' for \"Demand\"\nfor i, row in data.iterrows():\n    if row['series'] == \"Demand\":\n        if row['y-o-y change'] &gt; 0:\n            data.at[i, 'Position'] = data.at[i, 'Cumulative'] - row['y-o-y change']\n            data.at[i, 'y-o-y change'] = -row['y-o-y change']  # Invert the value for plotting\n        else:\n            data.at[i, 'Position'] = data.at[i, 'Cumulative'] - row['y-o-y change']\n\n\n# Plot the waterfall chart\nfig, ax = plt.subplots(figsize=(7.2, 4))\n\nbar_width = 0.8\n\n# Plot bars and connecting lines\nfor i, row in data.iterrows():\n    bar = ax.bar(row['series'], row['y-o-y change'], bottom=row['Position'], color=row['Color'], width=bar_width)\n    if i &lt; len(data) - 1:  # Draw connecting line to the next bar\n        next_row = data.iloc[i + 1]\n        line_position = row['Position'] + row['y-o-y change']\n        ax.plot([i - bar_width / 2, i + bar_width / 2 + 1], [line_position, line_position], color='black')\n\n# Add labels and values\nfor i, row in data.iterrows():\n    if row['series'] == \"Demand\":\n        value_text = f\"+{abs(row['y-o-y change']):.1f}\"\n    else:\n        value_text = f\"+{row['y-o-y change']:.1f}\" if row['y-o-y change'] &gt; 0 else f\"{row['y-o-y change']:.1f}\"\n    \n    if row['series'] in outside_labels:\n        if row['y-o-y change'] &gt; 0:\n            value_position = row['Position'] + row['y-o-y change'] + 1\n            label_position = value_position + 3\n            ax.text(i, value_position, value_text, ha='center', va='bottom', fontsize=8, color='black')\n            ax.text(i, label_position, row['series'], ha='center', va='bottom', fontsize=8, color='black')\n        else:\n            line_position = row['Position'] + row['y-o-y change']\n            label_position = line_position - 4\n            value_position = label_position - 3\n            ax.text(i, label_position, row['series'], ha='center', va='bottom', fontsize=8, color='black')\n            ax.text(i, value_position, value_text, ha='center', va='bottom', fontsize=8, color='black')\n    else:\n        ax.text(i, row['Position'] + row['y-o-y change'] / 2 + 2, row['series'], ha='center', va='center', fontsize=8, color='black')\n        ax.text(i, row['Position'] + row['y-o-y change'] / 2 - 2, value_text, ha='center', va='center', fontsize=8, color='black')\n\n\n\n# Customize plot\nax.axhline(0, color='gray', linewidth=0.8, zorder=0)\nax.set_ylim(y_min, y_max)\nax.set_yticks(y_ticks)\nax.set_yticklabels([f'{tick}' for tick in y_ticks], fontsize=8)\nax.set_xlabel(\"\")\nax.set_ylabel(f\"Change in electricity generation {quarter} TWh\", fontsize=8, labelpad=20, ha='center', weight='bold')\nax.yaxis.set_label_position(\"left\")\nax.yaxis.set_ticks_position('left')  # Add y-axis ticks\nax.yaxis.set_tick_params(width=2, color='gray', length=10, direction='inout', labelsize=8)  # Customize y ticks appearance\n\nplt.xticks(rotation=45, ha='right', fontsize=8)\nplt.grid(False)  # Remove grid\n# Remove all axis lines\nfor spine in ax.spines.values():\n    spine.set_visible(False)\nax.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False)  # Remove x axis ticks\nax.tick_params(axis='y', which='both', direction='in', length = 10, width = 0.5)  # Remove x axis ticks\n\n# Add title and subtitle \nfig.suptitle(title, fontsize=12, weight='bold', ha='left', fontname='Montserrat', x=0.01, y=0.98)\nfig.text(0.01, 0.9, subtitle, fontsize=10, ha='left', fontname='Open sans')\n\npdffile = outputfile+'.pdf'\nplt.tight_layout(rect=[0, 0, 1, 1])\nextent = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\nfig.savefig(pdffile, format='pdf', bbox_inches='tight')\n\n%matplotlib inline\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Optimization of Ember Electricity Generation Data with ARIMA Model and Regional EU Adjustments",
    "section": "",
    "text": "Ember methodology related to projected monthly data\nIn several cases monthly data is reported on a lagged basis, or data may not be available. In these cases, incomplete months are projected based on both seasonal and interannual trends. We aim to produce sensible figures (i.e. roughly what would be expected by eye), rather than trying to accurately account for e.g. unusual weather conditions in a given month. Projected data is not released for individual countries on a monthly level, but can play a small role in some monthly regional and country-level annual figures.\nThe approach uses a series of ARIMA models organised as follows:\nNotes on Ember data\nSteps for an approach to predict missing data and adjust fuel and country data to add up to Regional EU Ember:"
  },
  {
    "objectID": "index.html#check-overview-of-temporal-data",
    "href": "index.html#check-overview-of-temporal-data",
    "title": "Optimization of Ember Electricity Generation Data with ARIMA Model and Regional EU Adjustments",
    "section": "Check overview of temporal data",
    "text": "Check overview of temporal data\n\n\nCode\n### Check all the \"areas\" in the data\nunique(dfdown$Area)\n\n\n [1] \"Austria\"            \"Belgium\"            \"Bosnia Herzegovina\"\n [4] \"Bulgaria\"           \"Croatia\"            \"Cyprus\"            \n [7] \"Czechia\"            \"Denmark\"            \"Estonia\"           \n[10] \"EU\"                 \"Europe\"             \"Finland\"           \n[13] \"France\"             \"Germany\"            \"Greece\"            \n[16] \"Hungary\"            \"Ireland\"            \"Italy\"             \n[19] \"Kosovo\"             \"Latvia\"             \"Lithuania\"         \n[22] \"Luxembourg\"         \"Malta\"              \"Moldova\"           \n[25] \"Montenegro\"         \"Netherlands\"        \"North Macedonia\"   \n[28] \"Norway\"             \"Poland\"             \"Portugal\"          \n[31] \"Romania\"            \"Serbia\"             \"Slovakia\"          \n[34] \"Slovenia\"           \"Spain\"              \"Sweden\"            \n[37] \"Switzerland\"        \"Turkey\"             \"Ukraine\"           \n[40] \"United Kingdom\"    \n\n\nCode\n### Check all the \"variables\" in the data\nunique(dfdown$Variable)\n\n\n [1] \"Demand\"           \"Bioenergy\"        \"Coal\"             \"Gas\"             \n [5] \"Hydro\"            \"Other Fossil\"     \"Other Renewables\" \"Solar\"           \n [9] \"Wind\"             \"Total Generation\" \"Net Imports\"      \"Nuclear\"         \n\n\nCode\n### Get how many months of information per area with min and max months\nmonthsOverview &lt;- dfdown %&gt;%  \n  filter(Variable %in% 'Demand') %&gt;% \n  group_by(Area) %&gt;% \n  reframe(EU = unique(EU),\n          \"Total Months\" = n() , \n          \"Minimum Month\" = min(Date, na.rm = TRUE), \n          \"Maximum Month\" = max(Date, na.rm = TRUE))  \n\nmonthsOverview  %&gt;% \n  datatable(\n    filter = \"top\",  \n    rownames = FALSE, \n    extensions = 'Scroller', \n    options = list(\n      autoWidth = TRUE,\n      deferRender = TRUE,\n      scrollY = 300,\n      scrollX = TRUE,    # Enable horizontal scrolling\n      scroller = TRUE, \n      orderMulti = TRUE,  # Enable multiple column sorting\n      initComplete = JS(\n        \"function(settings, json) {\",\n        \"$('.dataTables_wrapper').css('font-size', '12px');\",  # Adjust font size here\n        \"}\"\n      )\n    ),\n    caption = htmltools::tags$caption(\n      style = 'caption-side: bottom; text-align: left; font-size: 12px; color: #777; font-style: italic;',\n      'Note: Hold Shift to sort by multiple columns'\n    )\n  )"
  },
  {
    "objectID": "index.html#compare-regional-with-estimated-demand-from-country-data",
    "href": "index.html#compare-regional-with-estimated-demand-from-country-data",
    "title": "Optimization of Ember Electricity Generation Data with ARIMA Model and Regional EU Adjustments",
    "section": "Compare regional with estimated demand from country data",
    "text": "Compare regional with estimated demand from country data\nRegional Europe and regional EU (Area column), estimated Europe (sum of countries from Ember region column), estimated EU (sum of countries from EU column) and BFF Europe (sum of BFF countries)\n\n\nCode\ndemandEUEuropeRegional &lt;- filter(dfdown, Area %in% c('EU', 'Europe'), \n                         Variable %in% 'Demand') %&gt;% \n  mutate(set = ifelse(Area == 'EU', \n                      'EU - regional', \n                      'Europe - regional'))\n\n## 39 countries\ndemandEuropeEstimated &lt;- filter(dfdown0, `Ember region` == 'Europe', \n                         Variable %in% 'Demand', \n                         ) %&gt;% \n  group_by(Date) %&gt;% \n  summarize(set = 'Europe - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandEUEstimated &lt;- filter(dfdown0, EU == 1, \n                         Variable %in% 'Demand') %&gt;% \n  group_by(Date) %&gt;% \n  summarize(set = 'EU - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandBFF &lt;- filter(dfdown, !Area %in% c('EU', 'Europe'), \n                         Variable %in% 'Demand') %&gt;% \n  group_by(Date) %&gt;% \n  summarize(set = 'BFF Europe - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandComp &lt;- bind_rows(demandEUEstimated, demandEuropeEstimated, demandEUEuropeRegional, demandBFF) %&gt;% \n  mutate(set = factor(set, levels=c('Europe - regional', \n                                    'Europe - estimated', \n                                    'BFF Europe - estimated',\n                                    'EU - regional',\n                                    'EU - estimated'))) \n\nq1 &lt;- demandComp %&gt;%\n  ggplot(aes(x = Date, y = Value, color = set)) +\n  geom_line() +\n  geom_point() +\n  theme_classic() +\n  labs(y = 'Demand TWh since 2015', x = NULL, colour = NULL) \n\nq2 &lt;- filter(demandComp, Date &gt;= \"2024-01-01\") %&gt;%\n  ggplot(aes(x = Date, y = Value, color = set)) +\n  geom_line() +\n  geom_point() +\n  theme_classic() +\n  labs(y = 'Demand TWh in 2024', x = NULL, colour = NULL) \n\n(q1 + q2 & theme(legend.position = \"bottom\")) + \n  plot_layout(guides = \"collect\", widths = c(2, 1))  \n\n\n\n\n\nCode\ndfdown1 &lt;- dfdown %&gt;%\n  filter(Date &gt;= \"2017-01-01\")\n\n\nBetter to use EU demand estimates to bound the model and only from 2017 onwards. Shouldn’t use Regional Europe to adjust non-EU countries since this includes Russia, although could remove the Russia data from Europe regional and make the adjustment, but given there is no net imports for Regional Europe, it might make more sense to use non-EU countries data without adjustment."
  },
  {
    "objectID": "index.html#identify-the-months-and-countries-missing-data-for-the-last-12-months",
    "href": "index.html#identify-the-months-and-countries-missing-data-for-the-last-12-months",
    "title": "Optimization of Ember Electricity Generation Data with ARIMA Model and Regional EU Adjustments",
    "section": "Identify the months and countries missing data for the last 12 months",
    "text": "Identify the months and countries missing data for the last 12 months\n\n\nCode\nmissing_data &lt;- dfdown1 %&gt;%\n  group_by(Area, Date, Variable) %&gt;%\n  summarize(EU = unique(EU),\n            missing = any(is.na(Value)), .groups = 'drop') \n\nlength(unique(missing_data$Date)) #months with available data to project since 2017\n\n\n[1] 91\n\n\nCode\nmissing_lastYear &lt;- missing_data %&gt;%\n  filter(Date &gt; today() - months(13)) %&gt;% # the current month won't have data\n  group_by(Area, Variable) %&gt;%\n  summarise(EU = unique(EU),\n            months_with_data = sum(!missing), .groups = 'drop') %&gt;%\n  pivot_wider(names_from = Variable, values_from = months_with_data, values_fill = 0) %&gt;% \n  relocate(c(Demand,`Net Imports`, `Total Generation`), .before = Bioenergy) %&gt;% \n  arrange(desc(EU), Area)\n\nmissing_lastYear %&gt;%  ##to get an overview for which countries and fuels there is data since June 2023 (not excluding zeros)\n  mutate_if(is.numeric, round, 3) %&gt;% \n  datatable(\n    filter = \"top\",  \n    rownames = FALSE, \n    extensions = 'Scroller', \n    options = list(autoWidth = TRUE,\n                   deferRender = TRUE,\n                   scrollY = 300,\n                   scrollX = TRUE,    # Enable horizontal scrolling\n                   scroller = TRUE, \n                   initComplete = JS(\n                     \"function(settings, json) {\",\n                     \"$('.dataTables_wrapper').css('font-size', '10px');\",  # Adjust font size here\n                     \"}\")))\n\n\n\n\n\n\n\nBetter to use demand to initially identify which countries and months to do the predictions"
  },
  {
    "objectID": "index.html#demand-adjustment-to-regional-eu",
    "href": "index.html#demand-adjustment-to-regional-eu",
    "title": "Optimization of Ember Electricity Generation Data with ARIMA Model and Regional EU Adjustments",
    "section": "Demand adjustment to Regional EU",
    "text": "Demand adjustment to Regional EU\n\nCompare against Regional EU demand\n\n\nCode\n# Aggregate the country-level Demand data for each month\ndemand_EU_Estimated &lt;- dfdown1 %&gt;%\n  filter(Variable == \"Demand\", EU == 1) %&gt;%\n  group_by(Date) %&gt;%\n  summarize(EU_Estimated = sum(Value, na.rm = TRUE), .groups = 'drop')\n\n# Extract the EU Demand data for the same months\ndemand_EU_Regional &lt;- dfdown1 %&gt;%\n  filter(Area == \"EU\", Variable == \"Demand\", Date %in% demand_EU_Estimated$Date) %&gt;%\n  select(Date, EU_Regional = Value)\n\n# Merge the country-aggregated and EU data for comparison\ncompEU &lt;- left_join(demand_EU_Estimated, demand_EU_Regional, by = \"Date\") %&gt;%\n  mutate(difference = EU_Regional - EU_Estimated)\n\n# View the comparison to see any discrepancies\n\nq3 &lt;- ggplot(compEU, aes(x = EU_Estimated, y = EU_Regional)) +\n  geom_abline() +\n  geom_smooth(method = 'lm') +\n  geom_point() +\n  theme_classic() + \n  scale_y_continuous(expand = c(0.01 ,0)) +\n  scale_x_continuous(expand = c(0.01 ,0))\n\nq4 &lt;- ggplot(compEU, aes(x = Date, y = difference)) +\n  geom_col() +\n  labs(y = \"Difference between regional and estimated EU demand\", x = NULL) +\n  scale_x_date(expand = c(0.01 ,0), date_breaks = \"1 year\", date_labels = \"%Y %b\") +\n  scale_y_continuous(expand = c(0.01 ,0)) +\n  theme_classic()\n\nq3 + q4\n\n\n\n\n\nThe estimated EU values from adding up all countries seem to be highly correlated enough but the difference seem to be higher prior to 2019.\n\n\nPredict demand missing data using ARIMA\n\n\nCode\ndemand_filtered &lt;- dfdown1 %&gt;%\n  filter(Date &gt;= \"2019-01-01\", \n         Variable == \"Demand\", \n         EU == 1)\n\n# Create a complete date sequence from min to max months used for all countries\nall_dates &lt;- seq(from = min(demand_filtered$Date), to = max(demand_filtered$Date), by = \"month\")\n\n# Generate a complete dataset with all Areas, all Dates and all variables\ncomplete_data &lt;- expand_grid(Area = unique(demand_filtered$Area), \n                             EU = 1,\n                             Date = all_dates, \n                             Variable = unique(dfdown1$Variable))\n\n# Filter to just demand data and left join with the existing demand_filtered to identify missing entries\ndemand_complete &lt;- complete_data %&gt;%\n  filter(Variable %in% 'Demand') %&gt;% \n  left_join(demand_filtered, by = c(\"EU\", \"Area\", \"Date\", \"Variable\"))  %&gt;% # Mark rows as missing where the Value is NA\n  mutate(missing = ifelse(is.na(Value), TRUE, FALSE))\n\ndemand_complete %&gt;%\n  group_by(Area) %&gt;%\n  summarize(missing_months = sum(missing), \n            total_months = n(), .groups = 'drop') %&gt;% \n  filter(missing_months != 0)\n\n\n# A tibble: 3 × 3\n  Area    missing_months total_months\n  &lt;chr&gt;            &lt;int&gt;        &lt;int&gt;\n1 Cyprus               2           67\n2 Ireland              1           67\n3 Malta                1           67\n\n\nCode\n# Function to fit ARIMA and predict missing data - needs to include the rows with the missing data to predict\npredict_missing_data &lt;- function(data) {\n  data &lt;- data %&gt;% \n    mutate(predicted = ifelse(is.na(Value), TRUE, FALSE)) # Create a new column to flag predicted values\n  \n  if(any(is.na(data$Value))) {\n    # Fit ARIMA model to non-missing data\n    fit &lt;- auto.arima(data$Value, seasonal = TRUE)\n    \n    # Predict missing values\n    missing_index &lt;- which(is.na(data$Value))\n    data$Value[missing_index] &lt;- forecast(fit, h = length(missing_index))$mean\n  }\n  \n  return(data)\n}\n\n# Apply the function to each country's Demand data\npredicted_data &lt;- demand_complete %&gt;%\n  group_by(Area) %&gt;%\n  nest() %&gt;%\n  mutate(data = map(data, predict_missing_data)) %&gt;%\n  unnest(data) %&gt;% \n  rename(pred_Value = Value)\n\nfilter(predicted_data, predicted == TRUE)\n\n\n# A tibble: 4 × 8\n# Groups:   Area [3]\n  Area       EU Date       Variable `Country code` pred_Value missing predicted\n  &lt;chr&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;               &lt;dbl&gt; &lt;lgl&gt;   &lt;lgl&gt;    \n1 Cyprus      1 2024-06-01 Demand   &lt;NA&gt;                0.425 TRUE    TRUE     \n2 Cyprus      1 2024-07-01 Demand   &lt;NA&gt;                0.403 TRUE    TRUE     \n3 Ireland     1 2024-07-01 Demand   &lt;NA&gt;                2.74  TRUE    TRUE     \n4 Malta       1 2024-07-01 Demand   &lt;NA&gt;                0.252 TRUE    TRUE     \n\n\n\n\nAdjust Predictions to Match EU Totals\n\n\nCode\n# Aggregate predicted data at the EU level\npredicted_EU_demand &lt;- predicted_data %&gt;%\n  group_by(Date) %&gt;%\n  summarize(predicted_EU = sum(pred_Value, na.rm = TRUE), .groups = 'drop')\n\n# Compare predicted EU data with EU Regional data\ncompEUpred &lt;- predicted_EU_demand %&gt;%\n  left_join(demand_EU_Regional, by = \"Date\") %&gt;%\n  mutate(adjustment_factor = EU_Regional / predicted_EU)\n\n# Apply the EU-wide adjustment to country-level predictions\npredAdjusted_data &lt;- predicted_data %&gt;%\n  left_join(select(compEUpred, Date, adjustment_factor), by = \"Date\") %&gt;%\n  mutate(PredAdjusted_Value = pred_Value * adjustment_factor) %&gt;%\n  select(-adjustment_factor)\n\nggplot(predAdjusted_data, aes(x = PredAdjusted_Value, \n                                       y = pred_Value)) +\n  geom_abline() +\n  geom_smooth(method = 'lm') +\n  geom_point(aes(size = predicted, shape = predicted)) +\n  theme_classic() + \n  scale_y_continuous(expand = c(0.01 ,0)) +\n  scale_x_continuous(expand = c(0.01 ,0)) +\n  scale_shape_manual(values = c(20,21)) +\n  labs(y = \"Demand with the values that were predicted\", \n       x = \"Demand with adjusted values given Regional EU demand\",\n       subtitle = paste(table(predAdjusted_data$predicted)[2], 'values were predicted'))\n\n\n\n\n\nCode\npaste0(\"Counts of values different between EU regional and adjusted estimated &gt; 0.00001: \",\n       predAdjusted_data %&gt;%\n  group_by(Date) %&gt;%\n  summarize(PredAdjusted_EU = sum(PredAdjusted_Value, na.rm = TRUE), .groups = 'drop') %&gt;%\n  left_join(compEUpred, by = 'Date') %&gt;%\n  tally(abs((EU_Regional-PredAdjusted_EU)) &gt; 0.00001) %&gt;% \n    pull(n))\n\n\n[1] \"Counts of values different between EU regional and adjusted estimated &gt; 0.00001: 0\"\n\n\nNo value has a difference bigger than 0.00001 between EU regional values and the adjusted and predicted added up EU estimates."
  },
  {
    "objectID": "index.html#net-imports-predictions-to-calculate-adjusted-total-generation-given-adjusted-to-eu-regional-demand",
    "href": "index.html#net-imports-predictions-to-calculate-adjusted-total-generation-given-adjusted-to-eu-regional-demand",
    "title": "Optimization of Ember Electricity Generation Data with ARIMA Model and Regional EU Adjustments",
    "section": "Net imports predictions to calculate adjusted total generation given adjusted to EU regional demand",
    "text": "Net imports predictions to calculate adjusted total generation given adjusted to EU regional demand\n\n\nCode\n## get the complete rows with the fuel values\ncomplete_data2 &lt;- left_join(complete_data, dfdown1) \n\n# Predict Net Imports using the ARIMA function\nnet_imports_data &lt;- complete_data2 %&gt;% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable == \"Net Imports\")  %&gt;%\n  group_by(Area) %&gt;%\n  nest() %&gt;%\n  mutate(data = map(data, predict_missing_data)) %&gt;%\n  unnest(data) %&gt;% \n  rename(pred_Imports = Value)\n\n# Predict Total Generation using the defined ARIMA function to keep if needed eventually\ntotal_generation_data &lt;- complete_data2 %&gt;% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable == \"Total Generation\")  %&gt;%\n  group_by(Area) %&gt;%\n  nest() %&gt;%\n  mutate(data = map(data, predict_missing_data)) %&gt;%\n  unnest(data) %&gt;% \n  rename(pred_Total = Value)\n\n# Get the adjusted Total generation from predicted Imports and predicted Demand\npred_missing_ImpTotal &lt;- filter(predAdjusted_data, predicted == TRUE) %&gt;%  \n  left_join(select(net_imports_data, Area, Date, pred_Imports)) %&gt;% \n  left_join(select(total_generation_data, Area, Date, pred_Total)) %&gt;% \n  rename(PredAdjusted_Demand = PredAdjusted_Value) %&gt;% \n  mutate(adjusted_Total = PredAdjusted_Demand - pred_Imports)\npred_missing_ImpTotal\n\n\n# A tibble: 4 × 12\n# Groups:   Area [3]\n  Area       EU Date       Variable `Country code` pred_Value missing predicted\n  &lt;chr&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;               &lt;dbl&gt; &lt;lgl&gt;   &lt;lgl&gt;    \n1 Cyprus      1 2024-06-01 Demand   &lt;NA&gt;                0.425 TRUE    TRUE     \n2 Cyprus      1 2024-07-01 Demand   &lt;NA&gt;                0.403 TRUE    TRUE     \n3 Ireland     1 2024-07-01 Demand   &lt;NA&gt;                2.74  TRUE    TRUE     \n4 Malta       1 2024-07-01 Demand   &lt;NA&gt;                0.252 TRUE    TRUE     \n# ℹ 4 more variables: PredAdjusted_Demand &lt;dbl&gt;, pred_Imports &lt;dbl&gt;,\n#   pred_Total &lt;dbl&gt;, adjusted_Total &lt;dbl&gt;"
  },
  {
    "objectID": "index.html#fuels-adjustment-to-eu-regional",
    "href": "index.html#fuels-adjustment-to-eu-regional",
    "title": "Optimization of Ember Electricity Generation Data with ARIMA Model and Regional EU Adjustments",
    "section": "Fuels adjustment to EU regional",
    "text": "Fuels adjustment to EU regional\nEstimate adjusted fuels by taking a adjusted total generation from the EU regional adjusted demand and the per country/fuel net imports.\n\nPrediction and adjustment for missing countries/months per fuel + country + month\n\n\nCode\n# Predict per fuel and adjust based on adjusted total\nfuel_types &lt;- filter(complete_data2, !Variable %in% \n                       c(\"Demand\",\"Net Imports\", \"Total Generation\")) %&gt;% \n  pull(Variable) %&gt;% \n  unique()\n\nmissingCountries_fuel_data &lt;- complete_data2 %&gt;% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable %in% fuel_types)  \n\nfinal_fuel_predictions &lt;- list()\n# Loop through each country with missing data\nfor (country in unique(pred_missing_ImpTotal$Area)) {\n  \n  missingDates &lt;- filter(predicted_data, predicted == TRUE, Area == country) %&gt;% \n    pull(Date)\n  \n  # Filter for the specific country\n  country_data &lt;- missingCountries_fuel_data %&gt;% \n    filter(Area == country) %&gt;%\n    ## deal with the fuels that are missing in historical data, consider them zeros. If not doing this it will predict values for month for which there is data\n    mutate(Value = case_when(!Date %in% missingDates & is.na(Value) ~ 0,\n                             TRUE~Value)) \n  \n  # Initialize an empty list to store fuel predictions for this country\n  country_fuel_predictions &lt;- list()\n  ## Loop through each fuel type\n  for (fuel in fuel_types) {\n    \n    # Predict fuel contribution using the defined ARIMA function\n    fuel_data &lt;- country_data %&gt;% \n      filter(Variable == fuel)\n    \n    predicted_fuel &lt;- predict_missing_data(fuel_data) %&gt;% \n      filter(predicted == TRUE)\n    \n    # Store the fuel predictions\n    country_fuel_predictions[[fuel]] &lt;- predicted_fuel\n  }\n  \n  # Combine all the fuel predictions for this country\n  country_fuels_df &lt;- bind_rows(country_fuel_predictions)\n  \n  # Check if the sum of predicted fuels matches the adjusted Total Generation\n  sum_predicted_fuels &lt;- country_fuels_df %&gt;% \n    group_by(Area, Date) %&gt;%\n    summarize(sum_fuels = sum(Value, na.rm = TRUE)) %&gt;% \n    left_join(select(pred_missing_ImpTotal, Area, Date, adjusted_Total)) %&gt;%\n    mutate(adjustment_factor = adjusted_Total / sum_fuels)\n  \n  # Store the adjusted fuel predictions for each country\n  final_fuel_predictions[[country]] &lt;- country_fuels_df %&gt;%\n    left_join(sum_predicted_fuels) %&gt;%\n    mutate(adjusted_valueFuel = Value * adjustment_factor) %&gt;%\n    select(Area, Date, Variable, Value, adjusted_valueFuel)\n}\n\n# Combine all missing countries' fuel predictions \nmissing_fuel_predictions_df &lt;- bind_rows(final_fuel_predictions)\n\nmissingFinal &lt;- select(pred_missing_ImpTotal, -Variable, -`Country code`, -missing) %&gt;% \n  rename(`Net Imports` = pred_Imports, `Total Generation` = pred_Total,\n         Demand = pred_Value, adjusted_Demand = PredAdjusted_Demand ) %&gt;% \n  left_join(missing_fuel_predictions_df)\n\n\n\n\nAdjustment of non missing countries/months\n\n\nCode\n# Create a DataFrame for fuels without the missing data\nnonmissing_fuel &lt;- complete_data2 %&gt;%\n  filter(Variable %in% fuel_types) %&gt;%\n  select(Area, EU, Date, Variable, Value) %&gt;% \n  replace_na(list(Value = 0)) ### assume missing fuels are just 0s\n\n# Left Join Net Imports, Total Generation, and Demand per fuel/country/date and get adjusted Total for non missing\nfuel_adjustment_data &lt;- complete_data2 %&gt;%\n    filter(!Variable %in% fuel_types) %&gt;%\n    select(Area, EU, Date, Variable, Value) %&gt;% \n  pivot_wider(names_from = Variable, values_from = Value) %&gt;% \n  left_join(nonmissing_fuel) %&gt;% \n  left_join(select(predAdjusted_data, Area, Date, predicted, PredAdjusted_Value)) %&gt;% \n  rename(PredAdjusted_Demand = PredAdjusted_Value) %&gt;%\n  mutate(adjusted_Total = PredAdjusted_Demand - `Net Imports`) %&gt;%\n    filter(predicted == FALSE)\n\n# Apply Adjustment Factor to Fuels for non missing\nadjusted_fuel_data &lt;- fuel_adjustment_data  %&gt;% \n  group_by(Area, Date) %&gt;%\n  mutate(sum_fuels = sum(Value, na.rm = TRUE),\n         adjustment_factor = adjusted_Total / sum_fuels,\n         adjusted_valueFuel = Value * adjustment_factor) %&gt;%\n  select(Area, Date, Variable, adjusted_valueFuel)\n\n# clean data for both missing and non missing as well demand/total/net imports and adjusted\nfinalDataEU &lt;- left_join(fuel_adjustment_data, adjusted_fuel_data) %&gt;% \n  rename(adjusted_Demand = PredAdjusted_Demand) %&gt;% \n  bind_rows(missingFinal) %&gt;% \n  relocate(c(EU, predicted,`Net Imports`, `Total Generation`, adjusted_Total, Demand, adjusted_Demand), .before = Variable) %&gt;% \n  rename(Fuel = Variable, Fuel_value = Value, AdjustedFuel_value = adjusted_valueFuel)\n\n\n\n\n\n\n\n\n\nSelect Fuel:\n\n\n\n\n\n\nSelect Country:"
  },
  {
    "objectID": "predictEmber_ARIMA.html",
    "href": "predictEmber_ARIMA.html",
    "title": "Optimization of Ember electricity generation data with ARIMA model and regional EU adjustments",
    "section": "",
    "text": "Ember methodology related to projected monthly data\nIn several cases monthly data is reported on a lagged basis, or data may not be available. In these cases, incomplete months are projected based on both seasonal and interannual trends. We aim to produce sensible figures (i.e. roughly what would be expected by eye), rather than trying to accurately account for e.g. unusual weather conditions in a given month. Projected data is not released for individual countries on a monthly level, but can play a small role in some monthly regional and country-level annual figures.\nThe approach uses a series of ARIMA models organised as follows:\nNotes on Ember data\nSteps for an approach to predict missing data and adjust fuel and country data to add up to Regional EU Ember:"
  },
  {
    "objectID": "predictEmber_ARIMA.html#check-overview-of-temporal-data",
    "href": "predictEmber_ARIMA.html#check-overview-of-temporal-data",
    "title": "Optimization of Ember electricity generation data with ARIMA model and regional EU adjustments",
    "section": "Check overview of temporal data",
    "text": "Check overview of temporal data\n\n\nCode\n### Check all the \"areas\" in the data\nunique(dfdown$Area)\n\n\n [1] \"Austria\"            \"Belgium\"            \"Bosnia Herzegovina\"\n [4] \"Bulgaria\"           \"Croatia\"            \"Cyprus\"            \n [7] \"Czechia\"            \"Denmark\"            \"Estonia\"           \n[10] \"EU\"                 \"Europe\"             \"Finland\"           \n[13] \"France\"             \"Germany\"            \"Greece\"            \n[16] \"Hungary\"            \"Ireland\"            \"Italy\"             \n[19] \"Kosovo\"             \"Latvia\"             \"Lithuania\"         \n[22] \"Luxembourg\"         \"Malta\"              \"Moldova\"           \n[25] \"Montenegro\"         \"Netherlands\"        \"North Macedonia\"   \n[28] \"Norway\"             \"Poland\"             \"Portugal\"          \n[31] \"Romania\"            \"Serbia\"             \"Slovakia\"          \n[34] \"Slovenia\"           \"Spain\"              \"Sweden\"            \n[37] \"Switzerland\"        \"Turkey\"             \"Ukraine\"           \n[40] \"United Kingdom\"    \n\n\nCode\n### Check all the \"variables\" in the data\nunique(dfdown$Variable)\n\n\n [1] \"Demand\"           \"Bioenergy\"        \"Coal\"             \"Gas\"             \n [5] \"Hydro\"            \"Other Fossil\"     \"Other Renewables\" \"Solar\"           \n [9] \"Wind\"             \"Total Generation\" \"Net Imports\"      \"Nuclear\"         \n\n\nCode\n### Get how many months of information per area with min and max months\nmonthsOverview &lt;- dfdown %&gt;%  \n  filter(Variable %in% 'Demand') %&gt;% \n  group_by(Area) %&gt;% \n  reframe(EU = unique(EU),\n          \"Total Months\" = n() , \n          \"Minimum Month\" = min(Date, na.rm = TRUE), \n          \"Maximum Month\" = max(Date, na.rm = TRUE))  \n\nmonthsOverview  %&gt;% \n  datatable(\n    filter = \"top\",  \n    rownames = FALSE, \n    extensions = 'Scroller', \n    options = list(\n      autoWidth = TRUE,\n      deferRender = TRUE,\n      scrollY = 300,\n      scrollX = TRUE,    # Enable horizontal scrolling\n      scroller = TRUE, \n      orderMulti = TRUE,  # Enable multiple column sorting\n      initComplete = JS(\n        \"function(settings, json) {\",\n        \"$('.dataTables_wrapper').css('font-size', '12px');\",  # Adjust font size here\n        \"}\"\n      )\n    ),\n    caption = htmltools::tags$caption(\n      style = 'caption-side: bottom; text-align: left; font-size: 12px; color: #777; font-style: italic;',\n      'Note: Hold Shift to sort by multiple columns'\n    )\n  )"
  },
  {
    "objectID": "predictEmber_ARIMA.html#compare-regional-with-estimated-demand-from-country-data",
    "href": "predictEmber_ARIMA.html#compare-regional-with-estimated-demand-from-country-data",
    "title": "Optimization of Ember electricity generation data with ARIMA model and regional EU adjustments",
    "section": "Compare regional with estimated demand from country data",
    "text": "Compare regional with estimated demand from country data\nRegional Europe and regional EU (Area column), estimated Europe (sum of countries from Ember region column), estimated EU (sum of countries from EU column) and BFF Europe (sum of BFF countries)\n\n\nCode\ndemandEUEuropeRegional &lt;- filter(dfdown, Area %in% c('EU', 'Europe'), \n                         Variable %in% 'Demand') %&gt;% \n  mutate(set = ifelse(Area == 'EU', \n                      'EU - regional', \n                      'Europe - regional'))\n\n## 39 countries\ndemandEuropeEstimated &lt;- filter(dfdown0, `Ember region` == 'Europe', \n                         Variable %in% 'Demand', \n                         ) %&gt;% \n  group_by(Date) %&gt;% \n  summarize(set = 'Europe - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandEUEstimated &lt;- filter(dfdown0, EU == 1, \n                         Variable %in% 'Demand') %&gt;% \n  group_by(Date) %&gt;% \n  summarize(set = 'EU - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandBFF &lt;- filter(dfdown, !Area %in% c('EU', 'Europe'), \n                         Variable %in% 'Demand') %&gt;% \n  group_by(Date) %&gt;% \n  summarize(set = 'BFF Europe - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandComp &lt;- bind_rows(demandEUEstimated, demandEuropeEstimated, demandEUEuropeRegional, demandBFF) %&gt;% \n  mutate(set = factor(set, levels=c('Europe - regional', \n                                    'Europe - estimated', \n                                    'BFF Europe - estimated',\n                                    'EU - regional',\n                                    'EU - estimated'))) \n\nq1 &lt;- demandComp %&gt;%\n  ggplot(aes(x = Date, y = Value, color = set)) +\n  geom_line() +\n  geom_point() +\n  theme_classic() +\n  labs(y = 'Demand TWh since 2015', x = NULL, colour = NULL) \n\nq2 &lt;- filter(demandComp, Date &gt;= \"2024-01-01\") %&gt;%\n  ggplot(aes(x = Date, y = Value, color = set)) +\n  geom_line() +\n  geom_point() +\n  theme_classic() +\n  labs(y = 'Demand TWh in 2024', x = NULL, colour = NULL) \n\n(q1 + q2 & theme(legend.position = \"bottom\")) + \n  plot_layout(guides = \"collect\", widths = c(2, 1))  \n\n\n\n\n\nCode\ndfdown1 &lt;- dfdown %&gt;%\n  filter(Date &gt;= \"2017-01-01\")\n\n\nBetter to use EU demand estimates to bound the model and only from 2017 onwards. Shouldn’t use Regional Europe to adjust non-EU countries since this includes Russia, although could remove the Russia data from Europe regional and make the adjustment, but given there is no net imports for Regional Europe, it might make more sense to use non-EU countries data without adjustment."
  },
  {
    "objectID": "predictEmber_ARIMA.html#identify-the-months-and-countries-missing-data-for-the-last-12-months",
    "href": "predictEmber_ARIMA.html#identify-the-months-and-countries-missing-data-for-the-last-12-months",
    "title": "Optimization of Ember electricity generation data with ARIMA model and regional EU adjustments",
    "section": "Identify the months and countries missing data for the last 12 months",
    "text": "Identify the months and countries missing data for the last 12 months\n\n\nCode\nmissing_data &lt;- dfdown1 %&gt;%\n  group_by(Area, Date, Variable) %&gt;%\n  summarize(EU = unique(EU),\n            missing = any(is.na(Value)), .groups = 'drop') \n\nlength(unique(missing_data$Date)) #months with available data to project since 2017\n\n\n[1] 91\n\n\nCode\nmissing_lastYear &lt;- missing_data %&gt;%\n  filter(Date &gt; today() - months(13)) %&gt;% # the current month won't have data\n  group_by(Area, Variable) %&gt;%\n  summarise(EU = unique(EU),\n            months_with_data = sum(!missing), .groups = 'drop') %&gt;%\n  pivot_wider(names_from = Variable, values_from = months_with_data, values_fill = 0) %&gt;% \n  relocate(c(Demand,`Net Imports`, `Total Generation`), .before = Bioenergy) %&gt;% \n  arrange(desc(EU), Area)\n\nmissing_lastYear %&gt;%  ##to get an overview for which countries and fuels there is data since June 2023 (not excluding zeros)\n  mutate_if(is.numeric, round, 3) %&gt;% \n  datatable(\n    filter = \"top\",  \n    rownames = FALSE, \n    extensions = 'Scroller', \n    options = list(autoWidth = TRUE,\n                   deferRender = TRUE,\n                   scrollY = 300,\n                   scrollX = TRUE,    # Enable horizontal scrolling\n                   scroller = TRUE, \n                   initComplete = JS(\n                     \"function(settings, json) {\",\n                     \"$('.dataTables_wrapper').css('font-size', '10px');\",  # Adjust font size here\n                     \"}\")))\n\n\n\n\n\n\n\nBetter to use demand to initially identify which countries and months to do the predictions"
  },
  {
    "objectID": "predictEmber_ARIMA.html#demand-adjustment-to-regional-eu",
    "href": "predictEmber_ARIMA.html#demand-adjustment-to-regional-eu",
    "title": "Optimization of Ember electricity generation data with ARIMA model and regional EU adjustments",
    "section": "Demand adjustment to Regional EU",
    "text": "Demand adjustment to Regional EU\n\nCompare against Regional EU demand\n\n\nCode\n# Aggregate the country-level Demand data for each month\ndemand_EU_Estimated &lt;- dfdown1 %&gt;%\n  filter(Variable == \"Demand\", EU == 1) %&gt;%\n  group_by(Date) %&gt;%\n  summarize(EU_Estimated = sum(Value, na.rm = TRUE), .groups = 'drop')\n\n# Extract the EU Demand data for the same months\ndemand_EU_Regional &lt;- dfdown1 %&gt;%\n  filter(Area == \"EU\", Variable == \"Demand\", Date %in% demand_EU_Estimated$Date) %&gt;%\n  select(Date, EU_Regional = Value)\n\n# Merge the country-aggregated and EU data for comparison\ncompEU &lt;- left_join(demand_EU_Estimated, demand_EU_Regional, by = \"Date\") %&gt;%\n  mutate(difference = EU_Regional - EU_Estimated)\n\n# View the comparison to see any discrepancies\n\nq3 &lt;- ggplot(compEU, aes(x = EU_Estimated, y = EU_Regional)) +\n  geom_abline() +\n  geom_smooth(method = 'lm') +\n  geom_point() +\n  theme_classic() + \n  scale_y_continuous(expand = c(0.01 ,0)) +\n  scale_x_continuous(expand = c(0.01 ,0))\n\nq4 &lt;- ggplot(compEU, aes(x = Date, y = difference)) +\n  geom_col() +\n  labs(y = \"Difference between regional and estimated EU demand\", x = NULL) +\n  scale_x_date(expand = c(0.01 ,0), date_breaks = \"1 year\", date_labels = \"%Y %b\") +\n  scale_y_continuous(expand = c(0.01 ,0)) +\n  theme_classic()\n\nq3 + q4\n\n\n\n\n\nThe estimated EU values from adding up all countries seem to be highly correlated enough but the difference seem to be higher prior to 2019.\n\n\nPredict demand missing data using ARIMA\n\n\nCode\ndemand_filtered &lt;- dfdown1 %&gt;%\n  filter(Date &gt;= \"2019-01-01\", \n         Variable == \"Demand\", \n         EU == 1)\n\n# Create a complete date sequence from min to max months used for all countries\nall_dates &lt;- seq(from = min(demand_filtered$Date), to = max(demand_filtered$Date), by = \"month\")\n\n# Generate a complete dataset with all Areas, all Dates and all variables\ncomplete_data &lt;- expand_grid(Area = unique(demand_filtered$Area), \n                             EU = 1,\n                             Date = all_dates, \n                             Variable = unique(dfdown1$Variable))\n\n# Filter to just demand data and left join with the existing demand_filtered to identify missing entries\ndemand_complete &lt;- complete_data %&gt;%\n  filter(Variable %in% 'Demand') %&gt;% \n  left_join(demand_filtered, by = c(\"EU\", \"Area\", \"Date\", \"Variable\"))  %&gt;% # Mark rows as missing where the Value is NA\n  mutate(missing = ifelse(is.na(Value), TRUE, FALSE))\n\ndemand_complete %&gt;%\n  group_by(Area) %&gt;%\n  summarize(missing_months = sum(missing), \n            total_months = n(), .groups = 'drop') %&gt;% \n  filter(missing_months != 0)\n\n\n# A tibble: 3 × 3\n  Area    missing_months total_months\n  &lt;chr&gt;            &lt;int&gt;        &lt;int&gt;\n1 Cyprus               2           67\n2 Ireland              1           67\n3 Malta                1           67\n\n\nCode\n# Function to fit ARIMA and predict missing data - needs to include the rows with the missing data to predict\npredict_missing_data &lt;- function(data) {\n  data &lt;- data %&gt;% \n    mutate(predicted = ifelse(is.na(Value), TRUE, FALSE)) # Create a new column to flag predicted values\n  \n  if(any(is.na(data$Value))) {\n    # Fit ARIMA model to non-missing data\n    fit &lt;- auto.arima(data$Value, seasonal = TRUE)\n    \n    # Predict missing values\n    missing_index &lt;- which(is.na(data$Value))\n    data$Value[missing_index] &lt;- forecast(fit, h = length(missing_index))$mean\n  }\n  \n  return(data)\n}\n\n# Apply the function to each country's Demand data\npredicted_data &lt;- demand_complete %&gt;%\n  group_by(Area) %&gt;%\n  nest() %&gt;%\n  mutate(data = map(data, predict_missing_data)) %&gt;%\n  unnest(data) %&gt;% \n  rename(pred_Value = Value)\n\nfilter(predicted_data, predicted == TRUE)\n\n\n# A tibble: 4 × 8\n# Groups:   Area [3]\n  Area       EU Date       Variable `Country code` pred_Value missing predicted\n  &lt;chr&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;               &lt;dbl&gt; &lt;lgl&gt;   &lt;lgl&gt;    \n1 Cyprus      1 2024-06-01 Demand   &lt;NA&gt;                0.425 TRUE    TRUE     \n2 Cyprus      1 2024-07-01 Demand   &lt;NA&gt;                0.403 TRUE    TRUE     \n3 Ireland     1 2024-07-01 Demand   &lt;NA&gt;                2.74  TRUE    TRUE     \n4 Malta       1 2024-07-01 Demand   &lt;NA&gt;                0.252 TRUE    TRUE     \n\n\n\n\nAdjust Predictions to Match EU Totals\n\n\nCode\n# Aggregate predicted data at the EU level\npredicted_EU_demand &lt;- predicted_data %&gt;%\n  group_by(Date) %&gt;%\n  summarize(predicted_EU = sum(pred_Value, na.rm = TRUE), .groups = 'drop')\n\n# Compare predicted EU data with EU Regional data\ncompEUpred &lt;- predicted_EU_demand %&gt;%\n  left_join(demand_EU_Regional, by = \"Date\") %&gt;%\n  mutate(adjustment_factor = EU_Regional / predicted_EU)\n\n# Apply the EU-wide adjustment to country-level predictions\npredAdjusted_data &lt;- predicted_data %&gt;%\n  left_join(select(compEUpred, Date, adjustment_factor), by = \"Date\") %&gt;%\n  mutate(PredAdjusted_Value = pred_Value * adjustment_factor) %&gt;%\n  select(-adjustment_factor)\n\nggplot(predAdjusted_data, aes(x = PredAdjusted_Value, \n                                       y = pred_Value)) +\n  geom_abline() +\n  geom_smooth(method = 'lm') +\n  geom_point(aes(size = predicted, shape = predicted)) +\n  theme_classic() + \n  scale_y_continuous(expand = c(0.01 ,0)) +\n  scale_x_continuous(expand = c(0.01 ,0)) +\n  scale_shape_manual(values = c(20,21)) +\n  labs(y = \"Demand with the values that were predicted\", \n       x = \"Demand with adjusted values given Regional EU demand\",\n       subtitle = paste(table(predAdjusted_data$predicted)[2], 'values were predicted'))\n\n\n\n\n\nCode\npaste0(\"Counts of values different between EU regional and adjusted estimated &gt; 0.00001: \",\n       predAdjusted_data %&gt;%\n  group_by(Date) %&gt;%\n  summarize(PredAdjusted_EU = sum(PredAdjusted_Value, na.rm = TRUE), .groups = 'drop') %&gt;%\n  left_join(compEUpred, by = 'Date') %&gt;%\n  tally(abs((EU_Regional-PredAdjusted_EU)) &gt; 0.00001) %&gt;% \n    pull(n))\n\n\n[1] \"Counts of values different between EU regional and adjusted estimated &gt; 0.00001: 0\"\n\n\nNo value has a difference bigger than 0.00001 between EU regional values and the adjusted and predicted added up EU estimates."
  },
  {
    "objectID": "predictEmber_ARIMA.html#net-imports-predictions-to-calculate-adjusted-total-generation-given-adjusted-to-eu-regional-demand",
    "href": "predictEmber_ARIMA.html#net-imports-predictions-to-calculate-adjusted-total-generation-given-adjusted-to-eu-regional-demand",
    "title": "Optimization of Ember electricity generation data with ARIMA model and regional EU adjustments",
    "section": "Net imports predictions to calculate adjusted total generation given adjusted to EU regional demand",
    "text": "Net imports predictions to calculate adjusted total generation given adjusted to EU regional demand\n\n\nCode\n## get the complete rows with the fuel values\ncomplete_data2 &lt;- left_join(complete_data, dfdown1) \n\n# Predict Net Imports using the ARIMA function\nnet_imports_data &lt;- complete_data2 %&gt;% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable == \"Net Imports\")  %&gt;%\n  group_by(Area) %&gt;%\n  nest() %&gt;%\n  mutate(data = map(data, predict_missing_data)) %&gt;%\n  unnest(data) %&gt;% \n  rename(pred_Imports = Value)\n\n# Predict Total Generation using the defined ARIMA function to keep if needed eventually\ntotal_generation_data &lt;- complete_data2 %&gt;% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable == \"Total Generation\")  %&gt;%\n  group_by(Area) %&gt;%\n  nest() %&gt;%\n  mutate(data = map(data, predict_missing_data)) %&gt;%\n  unnest(data) %&gt;% \n  rename(pred_Total = Value)\n\n# Get the adjusted Total generation from predicted Imports and predicted Demand\npred_missing_ImpTotal &lt;- filter(predAdjusted_data, predicted == TRUE) %&gt;%  \n  left_join(select(net_imports_data, Area, Date, pred_Imports)) %&gt;% \n  left_join(select(total_generation_data, Area, Date, pred_Total)) %&gt;% \n  rename(PredAdjusted_Demand = PredAdjusted_Value) %&gt;% \n  mutate(adjusted_Total = PredAdjusted_Demand - pred_Imports)\npred_missing_ImpTotal\n\n\n# A tibble: 4 × 12\n# Groups:   Area [3]\n  Area       EU Date       Variable `Country code` pred_Value missing predicted\n  &lt;chr&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;               &lt;dbl&gt; &lt;lgl&gt;   &lt;lgl&gt;    \n1 Cyprus      1 2024-06-01 Demand   &lt;NA&gt;                0.425 TRUE    TRUE     \n2 Cyprus      1 2024-07-01 Demand   &lt;NA&gt;                0.403 TRUE    TRUE     \n3 Ireland     1 2024-07-01 Demand   &lt;NA&gt;                2.74  TRUE    TRUE     \n4 Malta       1 2024-07-01 Demand   &lt;NA&gt;                0.252 TRUE    TRUE     \n# ℹ 4 more variables: PredAdjusted_Demand &lt;dbl&gt;, pred_Imports &lt;dbl&gt;,\n#   pred_Total &lt;dbl&gt;, adjusted_Total &lt;dbl&gt;"
  },
  {
    "objectID": "predictEmber_ARIMA.html#fuels-adjustment-to-eu-regional",
    "href": "predictEmber_ARIMA.html#fuels-adjustment-to-eu-regional",
    "title": "Optimization of Ember electricity generation data with ARIMA model and regional EU adjustments",
    "section": "Fuels adjustment to EU regional",
    "text": "Fuels adjustment to EU regional\nEstimate adjusted fuels by taking a adjusted total generation from the EU regional adjusted demand and the per country/fuel net imports.\n\nPrediction and adjustment for missing countries/months per fuel + country + month\n\n\nCode\n# Predict per fuel and adjust based on adjusted total\nfuel_types &lt;- filter(complete_data2, !Variable %in% \n                       c(\"Demand\",\"Net Imports\", \"Total Generation\")) %&gt;% \n  pull(Variable) %&gt;% \n  unique()\n\nmissingCountries_fuel_data &lt;- complete_data2 %&gt;% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable %in% fuel_types)  \n\nfinal_fuel_predictions &lt;- list()\n# Loop through each country with missing data\nfor (country in unique(pred_missing_ImpTotal$Area)) {\n  \n  missingDates &lt;- filter(predicted_data, predicted == TRUE, Area == country) %&gt;% \n    pull(Date)\n  \n  # Filter for the specific country\n  country_data &lt;- missingCountries_fuel_data %&gt;% \n    filter(Area == country) %&gt;%\n    ## deal with the fuels that are missing in historical data, consider them zeros. If not doing this it will predict values for month for which there is data\n    mutate(Value = case_when(!Date %in% missingDates & is.na(Value) ~ 0,\n                             TRUE~Value)) \n  \n  # Initialize an empty list to store fuel predictions for this country\n  country_fuel_predictions &lt;- list()\n  ## Loop through each fuel type\n  for (fuel in fuel_types) {\n    \n    # Predict fuel contribution using the defined ARIMA function\n    fuel_data &lt;- country_data %&gt;% \n      filter(Variable == fuel)\n    \n    predicted_fuel &lt;- predict_missing_data(fuel_data) %&gt;% \n      filter(predicted == TRUE)\n    \n    # Store the fuel predictions\n    country_fuel_predictions[[fuel]] &lt;- predicted_fuel\n  }\n  \n  # Combine all the fuel predictions for this country\n  country_fuels_df &lt;- bind_rows(country_fuel_predictions)\n  \n  # Check if the sum of predicted fuels matches the adjusted Total Generation\n  sum_predicted_fuels &lt;- country_fuels_df %&gt;% \n    group_by(Area, Date) %&gt;%\n    summarize(sum_fuels = sum(Value, na.rm = TRUE)) %&gt;% \n    left_join(select(pred_missing_ImpTotal, Area, Date, adjusted_Total)) %&gt;%\n    mutate(adjustment_factor = adjusted_Total / sum_fuels)\n  \n  # Store the adjusted fuel predictions for each country\n  final_fuel_predictions[[country]] &lt;- country_fuels_df %&gt;%\n    left_join(sum_predicted_fuels) %&gt;%\n    mutate(adjusted_valueFuel = Value * adjustment_factor) %&gt;%\n    select(Area, Date, Variable, Value, adjusted_valueFuel)\n}\n\n# Combine all missing countries' fuel predictions \nmissing_fuel_predictions_df &lt;- bind_rows(final_fuel_predictions)\n\nmissingFinal &lt;- select(pred_missing_ImpTotal, -Variable, -`Country code`, -missing) %&gt;% \n  rename(`Net Imports` = pred_Imports, `Total Generation` = pred_Total,\n         Demand = pred_Value, adjusted_Demand = PredAdjusted_Demand ) %&gt;% \n  left_join(missing_fuel_predictions_df)\n\n\n\n\nAdjustment of non missing countries/months\n\n\nCode\n# Create a DataFrame for fuels without the missing data\nnonmissing_fuel &lt;- complete_data2 %&gt;%\n  filter(Variable %in% fuel_types) %&gt;%\n  select(Area, EU, Date, Variable, Value) %&gt;% \n  replace_na(list(Value = 0)) ### assume missing fuels are just 0s\n\n# Left Join Net Imports, Total Generation, and Demand per fuel/country/date and get adjusted Total for non missing\nfuel_adjustment_data &lt;- complete_data2 %&gt;%\n    filter(!Variable %in% fuel_types) %&gt;%\n    select(Area, EU, Date, Variable, Value) %&gt;% \n  pivot_wider(names_from = Variable, values_from = Value) %&gt;% \n  left_join(nonmissing_fuel) %&gt;% \n  left_join(select(predAdjusted_data, Area, Date, predicted, PredAdjusted_Value)) %&gt;% \n  rename(PredAdjusted_Demand = PredAdjusted_Value) %&gt;%\n  mutate(adjusted_Total = PredAdjusted_Demand - `Net Imports`) %&gt;%\n    filter(predicted == FALSE)\n\n# Apply Adjustment Factor to Fuels for non missing\nadjusted_fuel_data &lt;- fuel_adjustment_data  %&gt;% \n  group_by(Area, Date) %&gt;%\n  mutate(sum_fuels = sum(Value, na.rm = TRUE),\n         adjustment_factor = adjusted_Total / sum_fuels,\n         adjusted_valueFuel = Value * adjustment_factor) %&gt;%\n  select(Area, Date, Variable, adjusted_valueFuel)\n\n# clean data for both missing and non missing as well demand/total/net imports and adjusted\nfinalDataEU &lt;- left_join(fuel_adjustment_data, adjusted_fuel_data) %&gt;% \n  rename(adjusted_Demand = PredAdjusted_Demand) %&gt;% \n  bind_rows(missingFinal) %&gt;% \n  relocate(c(EU, predicted,`Net Imports`, `Total Generation`, adjusted_Total, Demand, adjusted_Demand), .before = Variable) %&gt;% \n  rename(Fuel = Variable, Fuel_value = Value, AdjustedFuel_value = adjusted_valueFuel)\n\n\n\n\n\n\n\n\n\nSelect Fuel:\n\n\n\n\n\n\nSelect Country:"
  },
  {
    "objectID": "energy_generation_yoy_bar_chart.html",
    "href": "energy_generation_yoy_bar_chart.html",
    "title": "Import packages",
    "section": "",
    "text": "Code\nimport requests\nimport pandas as pd\nimport os\nimport time"
  },
  {
    "objectID": "energy_generation_yoy_bar_chart.html#api-access-parameters",
    "href": "energy_generation_yoy_bar_chart.html#api-access-parameters",
    "title": "Import packages",
    "section": "API access parameters",
    "text": "API access parameters\n\n\nCode\nmy_api_key = \"51356ef8-f7dd-43a1-9629-1965b7830a26\"\nbase_url = \"https://api.ember-climate.org\""
  },
  {
    "objectID": "energy_generation_yoy_bar_chart.html#parameters-for-the-charts",
    "href": "energy_generation_yoy_bar_chart.html#parameters-for-the-charts",
    "title": "Import packages",
    "section": "Parameters for the charts",
    "text": "Parameters for the charts\n\nCountries to import\n\n\nCode\niso_codes = [\n    \"ALB\",  # Albania\n    \"AUT\",  # Austria\n    \"BEL\",  # Belgium\n    \"BIH\",  # Bosnia and Herzegovina\n    \"BGR\",  # Bulgaria\n    \"HRV\",  # Croatia\n    \"CYP\",  # Cyprus\n    \"CZE\",  # Czech Republic\n    \"DNK\",  # Denmark\n    \"EST\",  # Estonia\n    \"FIN\",  # Finland\n    \"FRA\",  # France\n    \"DEU\",  # Germany\n    \"GRC\",  # Greece\n    \"HUN\",  # Hungary\n    \"IRL\",  # Ireland\n    \"ITA\",  # Italy\n    \"XKX\",  # Kosovo\n    \"LVA\",  # Latvia\n    \"LTU\",  # Lithuania\n    \"LUX\",  # Luxembourg\n    \"MLT\",  # Malta\n    \"MDA\",  # Moldova\n    \"MNE\",  # Montenegro\n    \"NLD\",  # Netherlands\n    \"MKD\",  # North Macedonia\n    \"NOR\",  # Norway\n    \"POL\",  # Poland\n    \"PRT\",  # Portugal\n    \"ROU\",  # Romania\n    \"SRB\",  # Serbia\n    \"SVK\",  # Slovakia\n    \"SVN\",  # Slovenia\n    \"ESP\",  # Spain\n    \"SWE\",  # Sweden\n    \"CHE\",  # Switzerland\n    \"TUR\",  # Turkey\n    \"GBR\",  # United Kingdom\n]\n\n\n\n\nNumber of months we want to display on the charts\n\n\nCode\nlast_month = 12\nlast_year = 2023\n\nnbr_months_rolling_year = 12\n\n\n\nListing the months we will have, based on the parameters we have chosen\n\n\nCode\nmonths_old_rolling_year = [\n    f\"{year}-{month:02d}-01\"\n    for year, month in [\n        time.localtime(\n            time.mktime((last_year - 1, last_month  - n, 1, 0, 0, 0, 0, 0, 0))\n        )[:2]\n        for n in range(nbr_months_rolling_year)\n    ]\n]\nmonths_new_rolling_year = [\n    f\"{year}-{month:02d}-01\"\n    for year, month in [\n        time.localtime(\n            time.mktime((last_year, last_month  - n, 1, 0, 0, 0, 0, 0, 0))\n        )[:2]\n        for n in range(nbr_months_rolling_year)\n    ]\n]\n\nmonths_expected = [\n    f\"{month:02d}\"\n    for year, month in [\n        time.localtime(\n            time.mktime((last_year, last_month  - n, 1, 0, 0, 0, 0, 0, 0))\n        )[:2]\n        for n in range(nbr_months_rolling_year)\n    ]\n]\n\n\n\n\nCode\nmonths_old_rolling_year\n\n\n['2022-12-01',\n '2022-11-01',\n '2022-10-01',\n '2022-09-01',\n '2022-08-01',\n '2022-07-01',\n '2022-06-01',\n '2022-05-01',\n '2022-04-01',\n '2022-03-01',\n '2022-02-01',\n '2022-01-01']\n\n\n\n\nCode\nmonths_new_rolling_year\n\n\n['2023-12-01',\n '2023-11-01',\n '2023-10-01',\n '2023-09-01',\n '2023-08-01',\n '2023-07-01',\n '2023-06-01',\n '2023-05-01',\n '2023-04-01',\n '2023-03-01',\n '2023-02-01',\n '2023-01-01']"
  },
  {
    "objectID": "energy_generation_yoy_bar_chart.html#running-the-api",
    "href": "energy_generation_yoy_bar_chart.html#running-the-api",
    "title": "Import packages",
    "section": "Running the API",
    "text": "Running the API\n\nQueries\n\n\nCode\nquery_url_generation = (\n    f\"{base_url}/v1/electricity-generation/monthly\"\n    + f\"?entity_code={','.join(iso_codes)}&is_aggregate_series=false&start_date=2000&api_key={my_api_key}\"\n)\n\nquery_url_demand = (\n    f\"{base_url}/v1/electricity-demand/monthly\"\n    + f\"?entity_code={','.join(iso_codes)}&is_aggregate_series=false&start_date=2000&api_key={my_api_key}\"\n)\n\n\n\n\nCode\nquery_url_generation\n\n\n'https://api.ember-climate.org/v1/electricity-generation/monthly?entity_code=ALB,AUT,BEL,BIH,BGR,HRV,CYP,CZE,DNK,EST,FIN,FRA,DEU,GRC,HUN,IRL,ITA,XKX,LVA,LTU,LUX,MLT,MDA,MNE,NLD,MKD,NOR,POL,PRT,ROU,SRB,SVK,SVN,ESP,SWE,CHE,TUR,GBR&is_aggregate_series=false&start_date=2000&api_key=51356ef8-f7dd-43a1-9629-1965b7830a26'\n\n\n\n\nCode\nquery_url_demand\n\n\n'https://api.ember-climate.org/v1/electricity-demand/monthly?entity_code=ALB,AUT,BEL,BIH,BGR,HRV,CYP,CZE,DNK,EST,FIN,FRA,DEU,GRC,HUN,IRL,ITA,XKX,LVA,LTU,LUX,MLT,MDA,MNE,NLD,MKD,NOR,POL,PRT,ROU,SRB,SVK,SVN,ESP,SWE,CHE,TUR,GBR&is_aggregate_series=false&start_date=2000&api_key=51356ef8-f7dd-43a1-9629-1965b7830a26'\n\n\n\n\nExecuting the queries. 200 = success\n\n\nCode\nresponse_generation = requests.get(query_url_generation)\nresponse_demand = requests.get(query_url_demand)\n\n\n\n\nCode\nresponse_generation.status_code\n\n\n200\n\n\n\n\nCode\nresponse_demand.status_code\n\n\n200"
  },
  {
    "objectID": "energy_generation_yoy_bar_chart.html#extracting-the-results",
    "href": "energy_generation_yoy_bar_chart.html#extracting-the-results",
    "title": "Import packages",
    "section": "Extracting the results",
    "text": "Extracting the results\n\n\nCode\ndata_generation = response_generation.json()[\"data\"]\ndata_demand = response_demand.json()[\"data\"]\ndf_generation = pd.DataFrame(data_generation)\ndf_demand = pd.DataFrame(data_demand)\n\n\n\n\nCode\ndf_generation\n\n\n\n\n\n\n\n\n\nentity\nentity_code\nis_aggregate_entity\ndate\nseries\nis_aggregate_series\ngeneration_twh\nshare_of_generation_pct\n\n\n\n\n0\nAustria\nAUT\nFalse\n2015-01-01\nBioenergy\nFalse\n0.23\n4.23\n\n\n1\nAustria\nAUT\nFalse\n2015-01-01\nCoal\nFalse\n0.26\n4.78\n\n\n2\nAustria\nAUT\nFalse\n2015-01-01\nGas\nFalse\n1.16\n21.32\n\n\n3\nAustria\nAUT\nFalse\n2015-01-01\nHydro\nFalse\n2.98\n54.78\n\n\n4\nAustria\nAUT\nFalse\n2015-01-01\nNet imports\nFalse\n2.08\n38.24\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n31012\nUnited Kingdom\nGBR\nFalse\n2024-06-01\nNet imports\nFalse\n2.95\n17.87\n\n\n31013\nUnited Kingdom\nGBR\nFalse\n2024-06-01\nNuclear\nFalse\n3.38\n20.47\n\n\n31014\nUnited Kingdom\nGBR\nFalse\n2024-06-01\nOther fossil\nFalse\n0.29\n1.76\n\n\n31015\nUnited Kingdom\nGBR\nFalse\n2024-06-01\nSolar\nFalse\n2.02\n12.24\n\n\n31016\nUnited Kingdom\nGBR\nFalse\n2024-06-01\nWind\nFalse\n5.17\n31.31\n\n\n\n\n31017 rows × 8 columns\n\n\n\n\n\nCode\ndf_demand\n\n\n\n\n\n\n\n\n\nentity\nentity_code\nis_aggregate_entity\ndate\ndemand_twh\n\n\n\n\n0\nAustria\nAUT\nFalse\n2015-01-01\n7.52\n\n\n1\nAustria\nAUT\nFalse\n2015-02-01\n6.34\n\n\n2\nAustria\nAUT\nFalse\n2015-03-01\n6.77\n\n\n3\nAustria\nAUT\nFalse\n2015-04-01\n5.89\n\n\n4\nAustria\nAUT\nFalse\n2015-05-01\n5.56\n\n\n...\n...\n...\n...\n...\n...\n\n\n3757\nUnited Kingdom\nGBR\nFalse\n2024-02-01\n23.19\n\n\n3758\nUnited Kingdom\nGBR\nFalse\n2024-03-01\n23.86\n\n\n3759\nUnited Kingdom\nGBR\nFalse\n2024-04-01\n21.88\n\n\n3760\nUnited Kingdom\nGBR\nFalse\n2024-05-01\n19.22\n\n\n3761\nUnited Kingdom\nGBR\nFalse\n2024-06-01\n19.46\n\n\n\n\n3762 rows × 5 columns\n\n\n\n\nFiltering only the data that we need\n\nWe extract the month from the date\n\n\nCode\ndf_generation[\"month\"] = df_generation[\"date\"].str[5:7]\ndf_demand[\"month\"] = df_demand[\"date\"].str[5:7]\n\n\n\n\nWe create one table with the current (‘new’) data, one table with the data we compare with (‘old’)\n\n\nCode\ndf_generation_old = df_generation.loc[\n        df_generation[\"date\"].isin(months_old_rolling_year)\n    ].copy()\ndf_generation_old[\"generation_twh_old\"] = df_generation_old[\"generation_twh\"]\ndf_generation_old = df_generation_old[\n        [\"entity\", \"entity_code\", \"month\", \"series\", \"generation_twh_old\"]\n    ]\ndf_generation_new = df_generation.loc[\n        df_generation[\"date\"].isin(months_new_rolling_year)\n    ].copy()\ndf_generation_new[\"generation_twh_new\"] = df_generation_new[\"generation_twh\"]\ndf_generation_new = df_generation_new[\n        [\"entity\", \"entity_code\", \"month\", \"series\", \"generation_twh_new\", \"date\"]\n    ]\n\n\n\n\nCode\ndf_demand_old = df_demand.loc[df_demand[\"date\"].isin(months_old_rolling_year)].copy()\ndf_demand_old[\"series\"] = \"Demand\"\ndf_demand_old[f\"generation_twh_old\"] = df_demand_old[\"demand_twh\"]\ndf_demand_old = df_demand_old[\n        [\"entity\", \"entity_code\", \"month\", \"series\", \"generation_twh_old\"]\n    ]\n\ndf_demand_new = df_demand.loc[df_demand[\"date\"].isin(months_new_rolling_year)].copy()\ndf_demand_new[\"series\"] = \"Demand\"\ndf_demand_new[f\"generation_twh_new\"] = df_demand_new[\"demand_twh\"]\ndf_demand_new = df_demand_new[\n        [\"entity\", \"entity_code\", \"month\", \"series\", \"generation_twh_new\", \"date\"]\n    ]\n\n\n\n\nWe merge generation and demand tables\n\n\nCode\ndf_old = pd.concat([df_generation_old, df_demand_old])\ndf_new = pd.concat([df_generation_new, df_demand_new])\n\n\n\n\nCode\ndf_old[(df_old.entity_code == 'IRL') & (df_old.month == '12')]\n\n\n\n\n\n\n\n\n\nentity\nentity_code\nmonth\nseries\ngeneration_twh_old\n\n\n\n\n13918\nIreland\nIRL\n12\nBioenergy\n0.01\n\n\n13919\nIreland\nIRL\n12\nCoal\n0.23\n\n\n13920\nIreland\nIRL\n12\nGas\n1.40\n\n\n13921\nIreland\nIRL\n12\nHydro\n0.09\n\n\n13922\nIreland\nIRL\n12\nNet imports\n0.25\n\n\n13923\nIreland\nIRL\n12\nOther fossil\n0.20\n\n\n13924\nIreland\nIRL\n12\nSolar\n0.00\n\n\n13925\nIreland\nIRL\n12\nWind\n1.03\n\n\n1604\nIreland\nIRL\n12\nDemand\n3.21\n\n\n\n\n\n\n\n\n\nWe merge the ‘old’ and ‘new’\n\n\nCode\ndf_all = pd.merge(\n        df_old, df_new, how=\"inner\", on=[\"entity\", \"entity_code\", \"series\", \"month\"]\n    )\n\n\n\n\nWe rename some categories\n\n\nCode\ndf_all[\"series\"] = df_all[\"series\"].apply(\n        lambda x: (\n            \"Other\"\n            if x in [\"Bioenergy\", \"Net imports\", \"Other renewables\", \"Other fossil\"]\n            else x\n        )\n    )\ndf_all = df_all.fillna(0)\n\n\n\n\n\nData checks\n\n\nCode\ncombinations = [(x, y) for x in iso_codes for y in months_expected]\nexpected_outcome = pd.DataFrame(combinations, columns=['entity_code', 'month'])\n\n\n\nMissing countries in generation - Old\n\n\nCode\ndf_generation_old_check = df_generation_old[df_generation_old.generation_twh_old &gt; 0]\ndf_generation_old_check = df_generation_old_check[['entity_code','month']].drop_duplicates()\n\nexpected_outcome[~expected_outcome.set_index(['entity_code','month']).index.isin(df_generation_old_check.set_index(['entity_code','month']).index)]\n\n\n\n\n\n\n\n\n\nentity_code\nmonth\n\n\n\n\n0\nALB\n12\n\n\n1\nALB\n11\n\n\n2\nALB\n10\n\n\n3\nALB\n09\n\n\n4\nALB\n08\n\n\n5\nALB\n07\n\n\n6\nALB\n06\n\n\n7\nALB\n05\n\n\n8\nALB\n04\n\n\n9\nALB\n03\n\n\n10\nALB\n02\n\n\n11\nALB\n01\n\n\n\n\n\n\n\n\n\nMissing countries in demand - Old\n\n\nCode\ndf_demand_old_check = df_demand_old[df_demand_old.generation_twh_old &gt; 0]\ndf_demand_old_check = df_demand_old_check[['entity_code','month']].drop_duplicates()\n\nexpected_outcome[~expected_outcome.set_index(['entity_code','month']).index.isin(df_demand_old_check.set_index(['entity_code','month']).index)]\n\n\n\n\n\n\n\n\n\nentity_code\nmonth\n\n\n\n\n0\nALB\n12\n\n\n1\nALB\n11\n\n\n2\nALB\n10\n\n\n3\nALB\n09\n\n\n4\nALB\n08\n\n\n5\nALB\n07\n\n\n6\nALB\n06\n\n\n7\nALB\n05\n\n\n8\nALB\n04\n\n\n9\nALB\n03\n\n\n10\nALB\n02\n\n\n11\nALB\n01\n\n\n\n\n\n\n\n\n\nMissing countries in generation - New\n\n\nCode\ndf_demand_new_check = df_demand_new[df_demand_new.generation_twh_new &gt; 0]\ndf_demand_new_check = df_demand_new_check[['entity_code','month']].drop_duplicates()\n\nexpected_outcome[~expected_outcome.set_index(['entity_code','month']).index.isin(df_demand_new_check.set_index(['entity_code','month']).index)]\n\n\n\n\n\n\n\n\n\nentity_code\nmonth\n\n\n\n\n0\nALB\n12\n\n\n1\nALB\n11\n\n\n2\nALB\n10\n\n\n3\nALB\n09\n\n\n4\nALB\n08\n\n\n5\nALB\n07\n\n\n6\nALB\n06\n\n\n7\nALB\n05\n\n\n8\nALB\n04\n\n\n9\nALB\n03\n\n\n10\nALB\n02\n\n\n11\nALB\n01\n\n\n\n\n\n\n\n\n\nMissing countries in demand - New\n\n\nCode\ndf_generation_new_check = df_generation_new[df_generation_new.generation_twh_new &gt; 0]\ndf_generation_new_check = df_generation_new_check[['entity_code','month']].drop_duplicates()\n\nexpected_outcome[~expected_outcome.set_index(['entity_code','month']).index.isin(df_generation_new_check.set_index(['entity_code','month']).index)]\n\n\n\n\n\n\n\n\n\nentity_code\nmonth\n\n\n\n\n0\nALB\n12\n\n\n1\nALB\n11\n\n\n2\nALB\n10\n\n\n3\nALB\n09\n\n\n4\nALB\n08\n\n\n5\nALB\n07\n\n\n6\nALB\n06\n\n\n7\nALB\n05\n\n\n8\nALB\n04\n\n\n9\nALB\n03\n\n\n10\nALB\n02\n\n\n11\nALB\n01\n\n\n\n\n\n\n\n\n\nCode\ndf_all[df_all.date == 0]\n\n\n\n\n\n\n\n\n\nentity\nentity_code\nmonth\nseries\ngeneration_twh_old\ngeneration_twh_new\ndate\n\n\n\n\n\n\n\n\n\n\n\n\nFinal data extraction\n\nWe extract what we need\n\n\nCode\noutput_rolling_year = (\n        df_all[\n            [\"month\", \"series\", \"date\", \"generation_twh_old\", \"generation_twh_new\"]\n        ]\n        .groupby([\"month\", \"series\", \"date\"])\n        .sum()\n        .reset_index()\n    )\noutput_rolling_year[\"y-o-y change\"] = (\n        output_rolling_year[\"generation_twh_new\"]\n        - output_rolling_year[\"generation_twh_old\"]\n    )\n\n\n\n\nCode\ncwd = os.getcwd()\nexcel_path_rolling_year = os.path.join(cwd, \"data_rolling_year.xlsx\")\noutput_rolling_year.to_excel(excel_path_rolling_year, index=False)\n\n\n\n\nCode\nexcel_path_rolling_year\n\n\n'/Users/acas/Dropbox/GitHub/Quarterly-slides/data_rolling_year.xlsx'\n\n\n\n\nCode\noutput_rolling_year\n\n\n\n\n\n\n\n\n\nmonth\nseries\ndate\ngeneration_twh_old\ngeneration_twh_new\ny-o-y change\n\n\n\n\n0\n01\nCoal\n2023-01-01\n55.03\n51.81\n-3.22\n\n\n1\n01\nDemand\n2023-01-01\n338.62\n317.45\n-21.17\n\n\n2\n01\nGas\n2023-01-01\n72.77\n54.47\n-18.30\n\n\n3\n01\nHydro\n2023-01-01\n48.95\n50.16\n1.21\n\n\n4\n01\nNuclear\n2023-01-01\n69.91\n63.08\n-6.83\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n91\n12\nHydro\n2023-12-01\n47.35\n58.69\n11.34\n\n\n92\n12\nNuclear\n2023-12-01\n60.66\n62.21\n1.55\n\n\n93\n12\nOther\n2023-12-01\n23.39\n21.02\n-2.37\n\n\n94\n12\nSolar\n2023-12-01\n5.57\n8.36\n2.79\n\n\n95\n12\nWind\n2023-12-01\n52.48\n69.78\n17.30\n\n\n\n\n96 rows × 6 columns"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]
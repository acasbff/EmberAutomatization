{"title":"Optimization of Ember Electricity Generation Data with ARIMA Model and Regional EU Adjustments","markdown":{"yaml":{"title":"Optimization of Ember Electricity Generation Data with ARIMA Model and Regional EU Adjustments","author":"Ana Afonso Silva","date":"`r Sys.Date()`"},"headingText":"setup of ember API function","containsRefs":false,"markdown":"\n\n```{r}\n#| echo: false\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(readxl)\nlibrary(showtext)\nlibrary(ggtext)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(lubridate)\nlibrary(forecast)\nlibrary(waterfalls)\nlibrary(here)\nlibrary(shadowtext)\nlibrary(ggh4x)\nlibrary(ggrepel)\nlibrary(kableExtra)\nlibrary(DT)\n\n# Set API key and base URL\n# my_api_key <- \"51356ef8-f7dd-43a1-9629-1965b7830a26\"\n# base_url <- \"https://api.ember-climate.org\"\n\n### needs to set the type of data, uses iso3 to fetch country data\n## frequency: \"yearly\", \"monthly\"\n## dataset:\"electricity-generation\", \"power-sector-emissions\", \"electricity-demand\", \"carbon-intensity\"\n  \n# fetch_EmberData <- function(dataset, iso_codes, api_key, frequency = \"monthly\") {\n#   valid_dataset <- c(\"capacity\",\"electricity-generation\", \"power-sector-emissions\", \"electricity-demand\", \"carbon-intensity\")\n#   valid_frequencies <- c(\"yearly\", \"monthly\")\n#   \n#   if (!(dataset %in% valid_dataset)) {\n#     stop(\"Invalid dataset name. Please use one of 'electricity-generation', 'power-sector-emissions', 'electricity-demand', or 'carbon-intensity'.\")\n#   }\n#   \n#   if (!(frequency %in% valid_frequencies)) {\n#     stop(\"Invalid frequency. Please use 'yearly' or 'monthly'.\")\n#   }\n#   \n#   query_url <- sprintf(\"%s/v1/%s/%s?entity_code=%s&is_aggregate_series=false&start_date=2000&api_key=%s\",\n#                        base_url, dataset, frequency, paste(iso_codes, collapse=\",\"), api_key)\n#   response <- GET(query_url)\n#   stop_for_status(response)\n#   content(response, as=\"text\", encoding = 'UTF-8') %>%\n#     fromJSON() %>%\n#     .$data %>%\n#     as_tibble()\n# }\n\n# # Provide quarter information\n# quarter <- 2 ### when running new quarter don't forget to change cache of API chunk to run\n# last_year <- 2024\n# nbr_months_waterfall <- 12 # using 12 to also get for the whole year and then just keep the quarter months\n# \n# # Map quarters to their corresponding months\n# quarter_months <- list(c(1, 3), c(4, 6), c(7, 9), c(10, 12))\n# last_month <- quarter_months[[quarter]][2]  # Get the last month of the quarter\n# \n# # Generate months function\n# generate_months <- function(last_year, last_month, nbr_months) {\n#   seq(as.Date(sprintf(\"%d-%02d-01\", last_year, last_month)) %m-% months(nbr_months-1),\n#       as.Date(sprintf(\"%d-%02d-01\", last_year, last_month)), by=\"1 month\")\n# }\n# \n# months_old_waterfall <- generate_months(last_year - 1, last_month, nbr_months_waterfall)\n# months_new_waterfall <- generate_months(last_year, last_month, nbr_months_waterfall)\n# months_expected <- format(months_new_waterfall, \"%m\")\n```\n\n**Ember methodology related to projected monthly data**\n\nIn several cases monthly data is reported on a lagged basis, or data may not be available. In these cases, incomplete months are projected based on both seasonal and interannual trends. We aim to produce sensible figures (i.e. roughly what would be expected by eye), rather than trying to accurately account for e.g. unusual weather conditions in a given month. Projected data is not released for individual countries on a monthly level, but can play a small role in some monthly regional and country-level annual figures.\n\nThe approach uses a series of ARIMA models organised as follows:\n\n-   Demand is projected using projected GDP from the world bank as an exogenous variable\n\n-   Non-dispatchable generation sources are projected. For this purpose we assume wind, solar, hydro, nuclear, and other renewables are not dispatchable\n\n-   Residual demand is calculated to be met by dispatchable generation and imports. Dispatchable generation (coal, gas, other fossil, and bio) is projected using residual demand as an exogenous variable\n\n-   Residual demand is recalculated to be met by imports. Imports are projected using this residual demand as an exogenous variable, with magnitude bounded at their historical maximum plus 10%.\n\n-   If there is any remaining discrepancy between projected demand and the sum of projected generation and imports, dispatchable generation is scaled to remove this\n\n------------------------------------------------------------------------\n\n**Notes on Ember data**\n\n-   Area has both all countries in BFF Europe (except for Albania, so 38 countries) and the regional estimates for both EU and Europe\n\n-   Regional Europe countries probably match the countries under \"Ember region\" == Europe column, but can't find confirmation for this in methodology\n\n-   \"Ember region\" == Europe column countries include Russia and there is no Albania data, the remaining countries match BFF Europe list (38 countries).\n\n-   EU regional has data for net imports while Europe regional does not, so we can use net imports predictions to adjust missing data for EU countries but not for non-EU countries.\n\n------------------------------------------------------------------------\n\n**Steps for an approach to predict missing data and adjust fuel and country data to add up to Regional EU Ember:**\n\n1.  Demand Analysis\n\n    a.  Identify missing demand data for countries/months.\n\n    b.  Predict missing demand using ARIMA models.\n\n    c.  Adjust country-level demand to match regional EU demand.\n\n2.  Generation and Imports:\n\n    a.  Predict missing Net Imports and Total Generation data.\n\n    b.  Calculate adjusted Total Generation using adjusted Demand and predicted Net Imports.\n\n3.  Fuel-Specific Data:\n\n    a.  Predict missing fuel-specific generation data.\n\n    b.  Adjust fuel data to ensure consistency with adjusted Total Generation.\n\n4.  Data Consolidation: Combine all processed data into a final, consistent dataset.\n\n------------------------------------------------------------------------\n\n# Explore data\n\nUse data from download file because we need regional EU data which is not available through the API.\n\n```{r}\n# Read the ISO codes from the file\niso_codes_df <- read.delim('/Users/acas/Dropbox/BFF/projects/BFFcountries.txt')\niso_codes <- iso_codes_df$Iso3\n\n## check for next releases if the link stays the same: https://ember-climate.org/app/uploads/2022/07/monthly_full_release_long_format-4.csv \n## this link has more data than the API, like the values for EU and Europe.\n\ndownload.file('https://ember-climate.org/app/uploads/2022/07/monthly_full_release_long_format-4.csv', paste0('monthly_full_release_long_format-4_',\n                     str_remove_all(Sys.Date(), \"-\"), \".csv\"), mode = \"wb\")\n\ndfdown0 <- read_csv(paste0('monthly_full_release_long_format-4_', \n                            str_remove_all(Sys.Date(), \"-\"), \".csv\"), show_col_types = FALSE) %>% \n                           #str_remove_all('20240826', \"-\"), \".csv\"), show_col_types = FALSE) %>% \n  filter(Date >= \"2015-01-01\")\n\n### keep data per fuel, total generated, net imports and demand\ndfdown <- dfdown0 %>% \n  filter(`Country code` %in% iso_codes | Area %in% c('EU','Europe'), # excludes Russia\n         !Category %in% c('Power sector emissions','Electricity prices'),\n         !Subcategory %in% 'Aggregate fuel',\n         Unit %in% 'TWh') %>% \n  select(Area, `Country code`, EU, Date, Variable, Value)\n```\n\n## Check overview of temporal data\n\n```{r}\n### Check all the \"areas\" in the data\nunique(dfdown$Area)\n\n### Check all the \"variables\" in the data\nunique(dfdown$Variable)\n\n### Get how many months of information per area with min and max months\nmonthsOverview <- dfdown %>%  \n  filter(Variable %in% 'Demand') %>% \n  group_by(Area) %>% \n  reframe(EU = unique(EU),\n          \"Total Months\" = n() , \n          \"Minimum Month\" = min(Date, na.rm = TRUE), \n          \"Maximum Month\" = max(Date, na.rm = TRUE))  \n\nmonthsOverview  %>% \n  datatable(\n    filter = \"top\",  \n    rownames = FALSE, \n    extensions = 'Scroller', \n    options = list(\n      autoWidth = TRUE,\n      deferRender = TRUE,\n      scrollY = 300,\n      scrollX = TRUE,    # Enable horizontal scrolling\n      scroller = TRUE, \n      orderMulti = TRUE,  # Enable multiple column sorting\n      initComplete = JS(\n        \"function(settings, json) {\",\n        \"$('.dataTables_wrapper').css('font-size', '12px');\",  # Adjust font size here\n        \"}\"\n      )\n    ),\n    caption = htmltools::tags$caption(\n      style = 'caption-side: bottom; text-align: left; font-size: 12px; color: #777; font-style: italic;',\n      'Note: Hold Shift to sort by multiple columns'\n    )\n  )\n```\n\n## Compare regional with estimated demand from country data\n\nRegional Europe and regional EU (Area column), estimated Europe (sum of countries from Ember region column), estimated EU (sum of countries from EU column) and BFF Europe (sum of BFF countries)\n\n```{r}\ndemandEUEuropeRegional <- filter(dfdown, Area %in% c('EU', 'Europe'), \n                         Variable %in% 'Demand') %>% \n  mutate(set = ifelse(Area == 'EU', \n                      'EU - regional', \n                      'Europe - regional'))\n\n## 39 countries\ndemandEuropeEstimated <- filter(dfdown0, `Ember region` == 'Europe', \n                         Variable %in% 'Demand', \n                         ) %>% \n  group_by(Date) %>% \n  summarize(set = 'Europe - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandEUEstimated <- filter(dfdown0, EU == 1, \n                         Variable %in% 'Demand') %>% \n  group_by(Date) %>% \n  summarize(set = 'EU - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandBFF <- filter(dfdown, !Area %in% c('EU', 'Europe'), \n                         Variable %in% 'Demand') %>% \n  group_by(Date) %>% \n  summarize(set = 'BFF Europe - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandComp <- bind_rows(demandEUEstimated, demandEuropeEstimated, demandEUEuropeRegional, demandBFF) %>% \n  mutate(set = factor(set, levels=c('Europe - regional', \n                                    'Europe - estimated', \n                                    'BFF Europe - estimated',\n                                    'EU - regional',\n                                    'EU - estimated'))) \n\nq1 <- demandComp %>%\n  ggplot(aes(x = Date, y = Value, color = set)) +\n  geom_line() +\n  geom_point() +\n  theme_classic() +\n  labs(y = 'Demand TWh since 2015', x = NULL, colour = NULL) \n\nq2 <- filter(demandComp, Date >= \"2024-01-01\") %>%\n  ggplot(aes(x = Date, y = Value, color = set)) +\n  geom_line() +\n  geom_point() +\n  theme_classic() +\n  labs(y = 'Demand TWh in 2024', x = NULL, colour = NULL) \n\n(q1 + q2 & theme(legend.position = \"bottom\")) + \n  plot_layout(guides = \"collect\", widths = c(2, 1))  \n\ndfdown1 <- dfdown %>%\n  filter(Date >= \"2017-01-01\")\n```\n\nBetter to use EU demand estimates to bound the model and only from 2017 onwards. Shouldn't use Regional Europe to adjust non-EU countries since this includes Russia, although could remove the Russia data from Europe regional and make the adjustment, but given there is no net imports for Regional Europe, it might make more sense to use non-EU countries data without adjustment.\n\n## Identify the months and countries missing data for the last 12 months\n\n```{r}\nmissing_data <- dfdown1 %>%\n  group_by(Area, Date, Variable) %>%\n  summarize(EU = unique(EU),\n            missing = any(is.na(Value)), .groups = 'drop') \n\nlength(unique(missing_data$Date)) #months with available data to project since 2017\nmissing_lastYear <- missing_data %>%\n  filter(Date > today() - months(13)) %>% # the current month won't have data\n  group_by(Area, Variable) %>%\n  summarise(EU = unique(EU),\n            months_with_data = sum(!missing), .groups = 'drop') %>%\n  pivot_wider(names_from = Variable, values_from = months_with_data, values_fill = 0) %>% \n  relocate(c(Demand,`Net Imports`, `Total Generation`), .before = Bioenergy) %>% \n  arrange(desc(EU), Area)\n\nmissing_lastYear %>%  ##to get an overview for which countries and fuels there is data since June 2023 (not excluding zeros)\n  mutate_if(is.numeric, round, 3) %>% \n  datatable(\n    filter = \"top\",  \n    rownames = FALSE, \n    extensions = 'Scroller', \n    options = list(autoWidth = TRUE,\n                   deferRender = TRUE,\n                   scrollY = 300,\n                   scrollX = TRUE,    # Enable horizontal scrolling\n                   scroller = TRUE, \n                   initComplete = JS(\n                     \"function(settings, json) {\",\n                     \"$('.dataTables_wrapper').css('font-size', '10px');\",  # Adjust font size here\n                     \"}\")))\n```\n\nBetter to use demand to initially identify which countries and months to do the predictions\n\n# EU countries adjustments with predictions when needed\n\n## Demand adjustment to Regional EU\n\n### Compare against Regional EU demand\n\n```{r}\n#| fig-height: 6    # Set default figure height for all chunks\n#| fig-width: 12  \n\n# Aggregate the country-level Demand data for each month\ndemand_EU_Estimated <- dfdown1 %>%\n  filter(Variable == \"Demand\", EU == 1) %>%\n  group_by(Date) %>%\n  summarize(EU_Estimated = sum(Value, na.rm = TRUE), .groups = 'drop')\n\n# Extract the EU Demand data for the same months\ndemand_EU_Regional <- dfdown1 %>%\n  filter(Area == \"EU\", Variable == \"Demand\", Date %in% demand_EU_Estimated$Date) %>%\n  select(Date, EU_Regional = Value)\n\n# Merge the country-aggregated and EU data for comparison\ncompEU <- left_join(demand_EU_Estimated, demand_EU_Regional, by = \"Date\") %>%\n  mutate(difference = EU_Regional - EU_Estimated)\n\n# View the comparison to see any discrepancies\n\nq3 <- ggplot(compEU, aes(x = EU_Estimated, y = EU_Regional)) +\n  geom_abline() +\n  geom_smooth(method = 'lm') +\n  geom_point() +\n  theme_classic() + \n  scale_y_continuous(expand = c(0.01 ,0)) +\n  scale_x_continuous(expand = c(0.01 ,0))\n\nq4 <- ggplot(compEU, aes(x = Date, y = difference)) +\n  geom_col() +\n  labs(y = \"Difference between regional and estimated EU demand\", x = NULL) +\n  scale_x_date(expand = c(0.01 ,0), date_breaks = \"1 year\", date_labels = \"%Y %b\") +\n  scale_y_continuous(expand = c(0.01 ,0)) +\n  theme_classic()\n\nq3 + q4\n```\n\nThe estimated EU values from adding up all countries seem to be highly correlated enough but the difference seem to be higher prior to 2019.\n\n### Predict demand missing data using ARIMA\n\n```{r}\ndemand_filtered <- dfdown1 %>%\n  filter(Date >= \"2019-01-01\", \n         Variable == \"Demand\", \n         EU == 1)\n\n# Create a complete date sequence from min to max months used for all countries\nall_dates <- seq(from = min(demand_filtered$Date), to = max(demand_filtered$Date), by = \"month\")\n\n# Generate a complete dataset with all Areas, all Dates and all variables\ncomplete_data <- expand_grid(Area = unique(demand_filtered$Area), \n                             EU = 1,\n                             Date = all_dates, \n                             Variable = unique(dfdown1$Variable))\n\n# Filter to just demand data and left join with the existing demand_filtered to identify missing entries\ndemand_complete <- complete_data %>%\n  filter(Variable %in% 'Demand') %>% \n  left_join(demand_filtered, by = c(\"EU\", \"Area\", \"Date\", \"Variable\"))  %>% # Mark rows as missing where the Value is NA\n  mutate(missing = ifelse(is.na(Value), TRUE, FALSE))\n\ndemand_complete %>%\n  group_by(Area) %>%\n  summarize(missing_months = sum(missing), \n            total_months = n(), .groups = 'drop') %>% \n  filter(missing_months != 0)\n\n\n# Function to fit ARIMA and predict missing data - needs to include the rows with the missing data to predict\npredict_missing_data <- function(data) {\n  data <- data %>% \n    mutate(predicted = ifelse(is.na(Value), TRUE, FALSE)) # Create a new column to flag predicted values\n  \n  if(any(is.na(data$Value))) {\n    # Fit ARIMA model to non-missing data\n    fit <- auto.arima(data$Value, seasonal = TRUE)\n    \n    # Predict missing values\n    missing_index <- which(is.na(data$Value))\n    data$Value[missing_index] <- forecast(fit, h = length(missing_index))$mean\n  }\n  \n  return(data)\n}\n\n# Apply the function to each country's Demand data\npredicted_data <- demand_complete %>%\n  group_by(Area) %>%\n  nest() %>%\n  mutate(data = map(data, predict_missing_data)) %>%\n  unnest(data) %>% \n  rename(pred_Value = Value)\n\nfilter(predicted_data, predicted == TRUE)\n```\n\n### Adjust Predictions to Match EU Totals\n\n```{r}\n#| fig-height: 6    # Set default figure height for all chunks\n#| fig-width: 8 \n \n# Aggregate predicted data at the EU level\npredicted_EU_demand <- predicted_data %>%\n  group_by(Date) %>%\n  summarize(predicted_EU = sum(pred_Value, na.rm = TRUE), .groups = 'drop')\n\n# Compare predicted EU data with EU Regional data\ncompEUpred <- predicted_EU_demand %>%\n  left_join(demand_EU_Regional, by = \"Date\") %>%\n  mutate(adjustment_factor = EU_Regional / predicted_EU)\n\n# Apply the EU-wide adjustment to country-level predictions\npredAdjusted_data <- predicted_data %>%\n  left_join(select(compEUpred, Date, adjustment_factor), by = \"Date\") %>%\n  mutate(PredAdjusted_Value = pred_Value * adjustment_factor) %>%\n  select(-adjustment_factor)\n\nggplot(predAdjusted_data, aes(x = PredAdjusted_Value, \n                                       y = pred_Value)) +\n  geom_abline() +\n  geom_smooth(method = 'lm') +\n  geom_point(aes(size = predicted, shape = predicted)) +\n  theme_classic() + \n  scale_y_continuous(expand = c(0.01 ,0)) +\n  scale_x_continuous(expand = c(0.01 ,0)) +\n  scale_shape_manual(values = c(20,21)) +\n  labs(y = \"Demand with the values that were predicted\", \n       x = \"Demand with adjusted values given Regional EU demand\",\n       subtitle = paste(table(predAdjusted_data$predicted)[2], 'values were predicted'))\n\npaste0(\"Counts of values different between EU regional and adjusted estimated > 0.00001: \",\n       predAdjusted_data %>%\n  group_by(Date) %>%\n  summarize(PredAdjusted_EU = sum(PredAdjusted_Value, na.rm = TRUE), .groups = 'drop') %>%\n  left_join(compEUpred, by = 'Date') %>%\n  tally(abs((EU_Regional-PredAdjusted_EU)) > 0.00001) %>% \n    pull(n))\n\n```\n\nNo value has a difference bigger than 0.00001 between EU regional values and the adjusted and predicted added up EU estimates.\n\n## Net imports predictions to calculate adjusted total generation given adjusted to EU regional demand\n\n```{r}\n## get the complete rows with the fuel values\ncomplete_data2 <- left_join(complete_data, dfdown1) \n\n# Predict Net Imports using the ARIMA function\nnet_imports_data <- complete_data2 %>% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable == \"Net Imports\")  %>%\n  group_by(Area) %>%\n  nest() %>%\n  mutate(data = map(data, predict_missing_data)) %>%\n  unnest(data) %>% \n  rename(pred_Imports = Value)\n\n# Predict Total Generation using the defined ARIMA function to keep if needed eventually\ntotal_generation_data <- complete_data2 %>% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable == \"Total Generation\")  %>%\n  group_by(Area) %>%\n  nest() %>%\n  mutate(data = map(data, predict_missing_data)) %>%\n  unnest(data) %>% \n  rename(pred_Total = Value)\n\n# Get the adjusted Total generation from predicted Imports and predicted Demand\npred_missing_ImpTotal <- filter(predAdjusted_data, predicted == TRUE) %>%  \n  left_join(select(net_imports_data, Area, Date, pred_Imports)) %>% \n  left_join(select(total_generation_data, Area, Date, pred_Total)) %>% \n  rename(PredAdjusted_Demand = PredAdjusted_Value) %>% \n  mutate(adjusted_Total = PredAdjusted_Demand - pred_Imports)\npred_missing_ImpTotal\n```\n\n## Fuels adjustment to EU regional\n\nEstimate adjusted fuels by taking a adjusted total generation from the EU regional adjusted demand and the per country/fuel net imports.\n\n### Prediction and adjustment for missing countries/months per fuel + country + month\n\n```{r}\n# Predict per fuel and adjust based on adjusted total\nfuel_types <- filter(complete_data2, !Variable %in% \n                       c(\"Demand\",\"Net Imports\", \"Total Generation\")) %>% \n  pull(Variable) %>% \n  unique()\n\nmissingCountries_fuel_data <- complete_data2 %>% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable %in% fuel_types)  \n\nfinal_fuel_predictions <- list()\n# Loop through each country with missing data\nfor (country in unique(pred_missing_ImpTotal$Area)) {\n  \n  missingDates <- filter(predicted_data, predicted == TRUE, Area == country) %>% \n    pull(Date)\n  \n  # Filter for the specific country\n  country_data <- missingCountries_fuel_data %>% \n    filter(Area == country) %>%\n    ## deal with the fuels that are missing in historical data, consider them zeros. If not doing this it will predict values for month for which there is data\n    mutate(Value = case_when(!Date %in% missingDates & is.na(Value) ~ 0,\n                             TRUE~Value)) \n  \n  # Initialize an empty list to store fuel predictions for this country\n  country_fuel_predictions <- list()\n  ## Loop through each fuel type\n  for (fuel in fuel_types) {\n    \n    # Predict fuel contribution using the defined ARIMA function\n    fuel_data <- country_data %>% \n      filter(Variable == fuel)\n    \n    predicted_fuel <- predict_missing_data(fuel_data) %>% \n      filter(predicted == TRUE)\n    \n    # Store the fuel predictions\n    country_fuel_predictions[[fuel]] <- predicted_fuel\n  }\n  \n  # Combine all the fuel predictions for this country\n  country_fuels_df <- bind_rows(country_fuel_predictions)\n  \n  # Check if the sum of predicted fuels matches the adjusted Total Generation\n  sum_predicted_fuels <- country_fuels_df %>% \n    group_by(Area, Date) %>%\n    summarize(sum_fuels = sum(Value, na.rm = TRUE)) %>% \n    left_join(select(pred_missing_ImpTotal, Area, Date, adjusted_Total)) %>%\n    mutate(adjustment_factor = adjusted_Total / sum_fuels)\n  \n  # Store the adjusted fuel predictions for each country\n  final_fuel_predictions[[country]] <- country_fuels_df %>%\n    left_join(sum_predicted_fuels) %>%\n    mutate(adjusted_valueFuel = Value * adjustment_factor) %>%\n    select(Area, Date, Variable, Value, adjusted_valueFuel)\n}\n\n# Combine all missing countries' fuel predictions \nmissing_fuel_predictions_df <- bind_rows(final_fuel_predictions)\n\nmissingFinal <- select(pred_missing_ImpTotal, -Variable, -`Country code`, -missing) %>% \n  rename(`Net Imports` = pred_Imports, `Total Generation` = pred_Total,\n         Demand = pred_Value, adjusted_Demand = PredAdjusted_Demand ) %>% \n  left_join(missing_fuel_predictions_df)\n```\n\n### Adjustment of non missing countries/months\n\n```{r}\n# Create a DataFrame for fuels without the missing data\nnonmissing_fuel <- complete_data2 %>%\n  filter(Variable %in% fuel_types) %>%\n  select(Area, EU, Date, Variable, Value) %>% \n  replace_na(list(Value = 0)) ### assume missing fuels are just 0s\n\n# Left Join Net Imports, Total Generation, and Demand per fuel/country/date and get adjusted Total for non missing\nfuel_adjustment_data <- complete_data2 %>%\n    filter(!Variable %in% fuel_types) %>%\n    select(Area, EU, Date, Variable, Value) %>% \n  pivot_wider(names_from = Variable, values_from = Value) %>% \n  left_join(nonmissing_fuel) %>% \n  left_join(select(predAdjusted_data, Area, Date, predicted, PredAdjusted_Value)) %>% \n  rename(PredAdjusted_Demand = PredAdjusted_Value) %>%\n  mutate(adjusted_Total = PredAdjusted_Demand - `Net Imports`) %>%\n    filter(predicted == FALSE)\n\n# Apply Adjustment Factor to Fuels for non missing\nadjusted_fuel_data <- fuel_adjustment_data  %>% \n  group_by(Area, Date) %>%\n  mutate(sum_fuels = sum(Value, na.rm = TRUE),\n         adjustment_factor = adjusted_Total / sum_fuels,\n         adjusted_valueFuel = Value * adjustment_factor) %>%\n  select(Area, Date, Variable, adjusted_valueFuel)\n\n# clean data for both missing and non missing as well demand/total/net imports and adjusted\nfinalDataEU <- left_join(fuel_adjustment_data, adjusted_fuel_data) %>% \n  rename(adjusted_Demand = PredAdjusted_Demand) %>% \n  bind_rows(missingFinal) %>% \n  relocate(c(EU, predicted,`Net Imports`, `Total Generation`, adjusted_Total, Demand, adjusted_Demand), .before = Variable) %>% \n  rename(Fuel = Variable, Fuel_value = Value, AdjustedFuel_value = adjusted_valueFuel)\n\n```\n\n------------------------------------------------------------------------\n\n```{r}\n#| echo: false\nlibrary(plotly)\nlibrary(crosstalk)\n\nfinalDataEU$predicted_Label <- ifelse(finalDataEU$predicted, \"Predicted\", \"Actual value\")\n\n# Create a SharedData object for linking the data with filters\nshared_finalData <- SharedData$new(finalDataEU)\n\n# Arrange the filters side by side using bscols\nbscols(\n  widths = c(3,NA),  # Adjust widths to fit your layout needs\n  \n  list(\n  filter_select(\"fuel\", \"Select Fuel:\", shared_finalData, ~Fuel),\n  filter_select(\"area\", \"Select Country:\", shared_finalData, ~Area)\n  ),\n  \n  # Create the Plotly scatter plot using color to differentiate 'predicted'\n  plot_ly(shared_finalData) %>%\n    add_trace(\n      x = ~AdjustedFuel_value,\n      y = ~Fuel_value,\n      color = ~predicted_Label,\n      colors = c('black', 'red'),\n      type = 'scatter',\n      mode = 'markers',\n      text = ~paste(\n        \"Date:\", Date,\n        \"<br>Actual generation:\", round(Fuel_value, 2),\n        \"<br>Adjusted generation:\", round(AdjustedFuel_value,2),\n        \"<br>Predicted value:\", predicted\n      ),\n      hoverinfo = 'text'  # Use the text provided in `text` for the tooltip\n    )  %>%\n    layout(\n      \n      title = \"Visualize how adjusted values compare to actual data per country and fuel\",\n      xaxis = list(\n        title = \"Adjusted fuel values given Regional EU\",\n        autorange = TRUE\n      ),\n      yaxis = list(\n        title = \"Actual fuel values\",\n        autorange = TRUE\n      )\n    )\n)\n```\n\n# Non-EU countries predictions\n\n-   Not doing adjustments based on regional data for these countries\n\n-   Moldova only has data starting in 2020 while Kosovo only has data starting in 2022, so it would be better to make predictions based on each country minimum month\n\n-   Exclude Ukraine from making predictions since data only goes until Sept 2022\n\n-   Predict data for fuels and net imports for each country then get demand and total generation from predicted data.\n\n```{r}\nnonEU_filtered <- dfdown1 %>%\n  filter(Date >= \"2019-01-01\",\n         !Area %in% 'Ukraine',\n         EU == 0)\n\n# get missing months per country based on Demand data\nnonEU_filtered_demand <- nonEU_filtered %>%\n  filter(Variable %in% \"Demand\") %>% \n  select(Area, Date, NotMissing = Variable)\n\n# Create a complete date sequence for the same date range as the EU dataset\nall_dates <- seq(from = min(finalDataEU$Date), to = max(finalDataEU$Date), by = \"month\")\n\n# need to exclude months of the 2 countries with minimum date after 2019\nset2 <- filter(monthsOverview, `Minimum Month` > min(nonEU_filtered$Date)) %>% \n  select(Area, Date = `Minimum Month`) %>% \n  mutate(remove = 1)\nset2\n\n# Generate a complete dataset with all Areas, all Dates and all variables\ncomplete_dataNonEU <- expand_grid(Area = unique(nonEU_filtered$Area), \n                             EU = 0,\n                             Date = all_dates, \n                             Variable = unique(nonEU_filtered$Variable))   %>%\n  left_join(set2, by = \"Area\")  %>%\n  filter(!(Date.y > Date.x) | is.na(remove) ) %>%  # exclude rows which Date is previous to minimum date available for a given country\n  select(-remove, -Date.y, Date = Date.x) %>% \n  left_join(dfdown1) %>% \n  left_join(nonEU_filtered_demand) %>% ### to deal with the values that are missing in historical data, consider them zeros. If not doing this it will predict values for month for which there is data\n  mutate(Value = ifelse(is.na(Value) & !is.na(NotMissing), 0, Value)) %>% \n  select(-NotMissing) \n\n## nonEU countries predicting data:\nmissingMonths <- filter(complete_dataNonEU, is.na(Value)) %>% \n  select( Area, Date) %>% \n  distinct()\n\nmissingMonths \n\n# Predict per fuel and for net imports\nfuelImp_types <- c(fuel_types, \"Net Imports\")\n\nnonEU_predictions <- list()\n# Loop through each country with missing data\nfor (country in unique(missingMonths$Area)) {\n  \n  # Filter for the specific country\n  country_data <- complete_dataNonEU %>% \n    filter(Area == country,\n           !Variable %in% c(\"Demand\", \"Total Generation\")) \n  \n  # Initialize an empty list to store fuel predictions for this country\n  country_fuel_predictions <- list()\n  ## Loop through each fuel type\n  for (fuel in fuelImp_types) {\n    \n    # Predict fuel contribution using the defined ARIMA function\n    fuel_data <- country_data %>% \n      filter(Variable == fuel)\n    \n    predicted_fuel <- predict_missing_data(fuel_data) %>% \n      filter(predicted == TRUE)\n    \n    # Store the fuel predictions\n    country_fuel_predictions[[fuel]] <- predicted_fuel\n  }\n  \n  # Combine all the fuel predictions for this country\n  country_fuels_df <- bind_rows(country_fuel_predictions)\n  \n  ## get total generation and demand from predicted data\n  Total_predicted_fuels <- country_fuels_df %>% \n    filter(!Variable %in% \"Net Imports\") %>% \n    group_by(Area, Date) %>%\n    summarize(`Total Generation` = sum(Value, na.rm = TRUE)) \n  \n  Demand_predicted_fuels <- country_fuels_df %>% \n    filter(Variable %in% \"Net Imports\") %>% \n    left_join(Total_predicted_fuels, by = join_by(Area, Date)) %>% \n    mutate(Demand = `Total Generation` + Value) %>% \n    select(Area, Date, `Net Imports` = Value, `Total Generation`, Demand)\n  \n  # Store the adjusted fuel predictions for each country\n  nonEU_predictions[[country]] <- country_fuels_df %>%\n    filter(!Variable %in% \"Net Imports\") %>% \n    left_join(Demand_predicted_fuels, by = join_by(Area, Date)) \n}\n\n# Combine all missing countries' fuel predictions \nnonEU_predictions_df <- bind_rows(nonEU_predictions) %>% \n  select(-`Country code`) \n\nFinal_nonEUComplete <- filter(complete_dataNonEU, !is.na(Value)) %>%\n  select(-`Country code`) %>% \n  pivot_wider(names_from = Variable, values_from = Value) %>% \n  pivot_longer(cols = !!fuel_types, names_to = 'Variable', values_to = 'Value') %>% \n  mutate(predicted = FALSE) %>% \n  bind_rows(nonEU_predictions_df) %>% \n  rename(Fuel = 'Variable', Fuel_value = 'Value')\n```\n\n# Bringing together EU and nonEU data\n\n```{r}\n# clean data for both missing and non missing as well demand/total/net imports and adjusted, for EU and nonEU countries (not with adjusted values)\nfinalData <- bind_rows(finalDataEU[-13], Final_nonEUComplete)\n```\n\n```{r}\n#| echo: false\n#| warning: false\n#| message: false\n\nfinalData %>%\n  mutate_if(is.numeric, round, 3) %>% \n      datatable(\n    filter = \"top\",  \n    rownames = FALSE, \n    extensions = 'Scroller', \n    options = list(\n      autoWidth = TRUE,\n      deferRender = TRUE,\n      scrollY = 400,\n      scrollX = TRUE,    # Enable horizontal scrolling\n      scroller = TRUE, \n      orderMulti = TRUE,  # Enable multiple column sorting\n      initComplete = JS(\n        \"function(settings, json) {\",\n        \"$('.dataTables_wrapper').css('font-size', '10px');\",  # Adjust font size here\n        \"}\"\n      )\n    ),\n    caption = htmltools::tags$caption(\n      style = 'caption-side: bottom; text-align: left; font-size: 10px; color: #777; font-style: italic;',\n      'Note: Hold Shift to sort by multiple columns'\n    )\n  )\n```\n\n------------------------------------------------------------------------\n\nVisualizing fuel per country (with predicted but not adjusted data)\n\n```{r}\n#| echo: false\n#| warning: false\n#| message: false\n\nlibrary(jsonlite)\n# Prepare all data\nall_data <- finalData %>%\n  select(Area, Date, Fuel, Fuel_value)\n\n# Get unique areas for the dropdown\nareas <- unique(all_data$Area)\n\n# Convert to JSON for use in Observable\nojs_define(all_data_json = toJSON(all_data))\nojs_define(areas_json = toJSON(areas))\n```\n\n```{ojs}\n//| echo: false\n\n// Parse the JSON data\ndata = JSON.parse(all_data_json)\nareas = JSON.parse(areas_json)\n\n// Create a dropdown for area selection\nviewof selectedArea = Inputs.select(areas, {label: \"Select Area\", value: areas[0]})\n\n// Define fuel types\nfuels = [\"Solar\", \"Wind\",\"Other Renewables\", \"Coal\", \"Gas\",  \"Other Fossil\", \"Hydro\",\"Bioenergy\",  \"Nuclear\"]\n\n// Function to filter and prepare data\nfunction prepareData(area, fuel) {\n  return data\n    .filter(d => d.Area === area && d.Fuel === fuel)\n    .map(d => ({...d, Year: d.Date.substring(0, 4)}));\n}\n\n// Function to create a single plot\nfunction createPlot(fuel) {\n  const plotData = prepareData(selectedArea, fuel);\n  \n  // Check for empty data or data with only zero values\n  if (plotData.length === 0 || plotData.every(d => d.Fuel_value === 0)) {\n    return html`<div style=\"width: 200px; height: 200px; display: flex; justify-content: right; align-items: center; \">\n      <p></p>\n    </div>`;\n  }\n  \n  return Plot.plot({\n      style: {\n      fontSize: \"12px\",\n      fontFamily: \"OpenSans, sans-serif\"\n    },\n    y: {grid: true, label: \"\", \n    tickSize: 0\n      },\n    x: {\n      label: \"\",\n      tickFormat: d => d.endsWith(\"-01-01\") ? d.substring(0, 4) : \"\",\n      ticks: plotData\n        .filter(d => d.Date.endsWith(\"-01-01\"))\n        .map(d => d.Date),\n    },\n    marks: [\n      Plot.barY(plotData, {\n        x: \"Date\", \n        y: \"Fuel_value\", \n        fill: \"steelblue\",\n         tip: true,\n        title: d => `Date: ${d.Date}\\nGeneration: ${d.Fuel_value.toFixed(2)} TWh`\n      })\n    ],\n    width: 300,\n    height: 300,\n    title: fuel  // Set the fuel type as the title\n  })\n}\n\n// Create a 3x3 grid of plots\nhtml`<div style=\"display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px;\">\n  ${fuels.map(fuel => html`<div>\n    <h3 style=\"text-align: center; margin-bottom: 1px;\">${fuel}</h3>\n    ${createPlot(fuel)}\n  </div>`)}\n</div>`\n```\n","srcMarkdownNoYaml":"\n\n```{r}\n#| echo: false\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(readxl)\nlibrary(showtext)\nlibrary(ggtext)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(lubridate)\nlibrary(forecast)\nlibrary(waterfalls)\nlibrary(here)\nlibrary(shadowtext)\nlibrary(ggh4x)\nlibrary(ggrepel)\nlibrary(kableExtra)\nlibrary(DT)\n\n### setup of ember API function\n# Set API key and base URL\n# my_api_key <- \"51356ef8-f7dd-43a1-9629-1965b7830a26\"\n# base_url <- \"https://api.ember-climate.org\"\n\n### needs to set the type of data, uses iso3 to fetch country data\n## frequency: \"yearly\", \"monthly\"\n## dataset:\"electricity-generation\", \"power-sector-emissions\", \"electricity-demand\", \"carbon-intensity\"\n  \n# fetch_EmberData <- function(dataset, iso_codes, api_key, frequency = \"monthly\") {\n#   valid_dataset <- c(\"capacity\",\"electricity-generation\", \"power-sector-emissions\", \"electricity-demand\", \"carbon-intensity\")\n#   valid_frequencies <- c(\"yearly\", \"monthly\")\n#   \n#   if (!(dataset %in% valid_dataset)) {\n#     stop(\"Invalid dataset name. Please use one of 'electricity-generation', 'power-sector-emissions', 'electricity-demand', or 'carbon-intensity'.\")\n#   }\n#   \n#   if (!(frequency %in% valid_frequencies)) {\n#     stop(\"Invalid frequency. Please use 'yearly' or 'monthly'.\")\n#   }\n#   \n#   query_url <- sprintf(\"%s/v1/%s/%s?entity_code=%s&is_aggregate_series=false&start_date=2000&api_key=%s\",\n#                        base_url, dataset, frequency, paste(iso_codes, collapse=\",\"), api_key)\n#   response <- GET(query_url)\n#   stop_for_status(response)\n#   content(response, as=\"text\", encoding = 'UTF-8') %>%\n#     fromJSON() %>%\n#     .$data %>%\n#     as_tibble()\n# }\n\n# # Provide quarter information\n# quarter <- 2 ### when running new quarter don't forget to change cache of API chunk to run\n# last_year <- 2024\n# nbr_months_waterfall <- 12 # using 12 to also get for the whole year and then just keep the quarter months\n# \n# # Map quarters to their corresponding months\n# quarter_months <- list(c(1, 3), c(4, 6), c(7, 9), c(10, 12))\n# last_month <- quarter_months[[quarter]][2]  # Get the last month of the quarter\n# \n# # Generate months function\n# generate_months <- function(last_year, last_month, nbr_months) {\n#   seq(as.Date(sprintf(\"%d-%02d-01\", last_year, last_month)) %m-% months(nbr_months-1),\n#       as.Date(sprintf(\"%d-%02d-01\", last_year, last_month)), by=\"1 month\")\n# }\n# \n# months_old_waterfall <- generate_months(last_year - 1, last_month, nbr_months_waterfall)\n# months_new_waterfall <- generate_months(last_year, last_month, nbr_months_waterfall)\n# months_expected <- format(months_new_waterfall, \"%m\")\n```\n\n**Ember methodology related to projected monthly data**\n\nIn several cases monthly data is reported on a lagged basis, or data may not be available. In these cases, incomplete months are projected based on both seasonal and interannual trends. We aim to produce sensible figures (i.e. roughly what would be expected by eye), rather than trying to accurately account for e.g. unusual weather conditions in a given month. Projected data is not released for individual countries on a monthly level, but can play a small role in some monthly regional and country-level annual figures.\n\nThe approach uses a series of ARIMA models organised as follows:\n\n-   Demand is projected using projected GDP from the world bank as an exogenous variable\n\n-   Non-dispatchable generation sources are projected. For this purpose we assume wind, solar, hydro, nuclear, and other renewables are not dispatchable\n\n-   Residual demand is calculated to be met by dispatchable generation and imports. Dispatchable generation (coal, gas, other fossil, and bio) is projected using residual demand as an exogenous variable\n\n-   Residual demand is recalculated to be met by imports. Imports are projected using this residual demand as an exogenous variable, with magnitude bounded at their historical maximum plus 10%.\n\n-   If there is any remaining discrepancy between projected demand and the sum of projected generation and imports, dispatchable generation is scaled to remove this\n\n------------------------------------------------------------------------\n\n**Notes on Ember data**\n\n-   Area has both all countries in BFF Europe (except for Albania, so 38 countries) and the regional estimates for both EU and Europe\n\n-   Regional Europe countries probably match the countries under \"Ember region\" == Europe column, but can't find confirmation for this in methodology\n\n-   \"Ember region\" == Europe column countries include Russia and there is no Albania data, the remaining countries match BFF Europe list (38 countries).\n\n-   EU regional has data for net imports while Europe regional does not, so we can use net imports predictions to adjust missing data for EU countries but not for non-EU countries.\n\n------------------------------------------------------------------------\n\n**Steps for an approach to predict missing data and adjust fuel and country data to add up to Regional EU Ember:**\n\n1.  Demand Analysis\n\n    a.  Identify missing demand data for countries/months.\n\n    b.  Predict missing demand using ARIMA models.\n\n    c.  Adjust country-level demand to match regional EU demand.\n\n2.  Generation and Imports:\n\n    a.  Predict missing Net Imports and Total Generation data.\n\n    b.  Calculate adjusted Total Generation using adjusted Demand and predicted Net Imports.\n\n3.  Fuel-Specific Data:\n\n    a.  Predict missing fuel-specific generation data.\n\n    b.  Adjust fuel data to ensure consistency with adjusted Total Generation.\n\n4.  Data Consolidation: Combine all processed data into a final, consistent dataset.\n\n------------------------------------------------------------------------\n\n# Explore data\n\nUse data from download file because we need regional EU data which is not available through the API.\n\n```{r}\n# Read the ISO codes from the file\niso_codes_df <- read.delim('/Users/acas/Dropbox/BFF/projects/BFFcountries.txt')\niso_codes <- iso_codes_df$Iso3\n\n## check for next releases if the link stays the same: https://ember-climate.org/app/uploads/2022/07/monthly_full_release_long_format-4.csv \n## this link has more data than the API, like the values for EU and Europe.\n\ndownload.file('https://ember-climate.org/app/uploads/2022/07/monthly_full_release_long_format-4.csv', paste0('monthly_full_release_long_format-4_',\n                     str_remove_all(Sys.Date(), \"-\"), \".csv\"), mode = \"wb\")\n\ndfdown0 <- read_csv(paste0('monthly_full_release_long_format-4_', \n                            str_remove_all(Sys.Date(), \"-\"), \".csv\"), show_col_types = FALSE) %>% \n                           #str_remove_all('20240826', \"-\"), \".csv\"), show_col_types = FALSE) %>% \n  filter(Date >= \"2015-01-01\")\n\n### keep data per fuel, total generated, net imports and demand\ndfdown <- dfdown0 %>% \n  filter(`Country code` %in% iso_codes | Area %in% c('EU','Europe'), # excludes Russia\n         !Category %in% c('Power sector emissions','Electricity prices'),\n         !Subcategory %in% 'Aggregate fuel',\n         Unit %in% 'TWh') %>% \n  select(Area, `Country code`, EU, Date, Variable, Value)\n```\n\n## Check overview of temporal data\n\n```{r}\n### Check all the \"areas\" in the data\nunique(dfdown$Area)\n\n### Check all the \"variables\" in the data\nunique(dfdown$Variable)\n\n### Get how many months of information per area with min and max months\nmonthsOverview <- dfdown %>%  \n  filter(Variable %in% 'Demand') %>% \n  group_by(Area) %>% \n  reframe(EU = unique(EU),\n          \"Total Months\" = n() , \n          \"Minimum Month\" = min(Date, na.rm = TRUE), \n          \"Maximum Month\" = max(Date, na.rm = TRUE))  \n\nmonthsOverview  %>% \n  datatable(\n    filter = \"top\",  \n    rownames = FALSE, \n    extensions = 'Scroller', \n    options = list(\n      autoWidth = TRUE,\n      deferRender = TRUE,\n      scrollY = 300,\n      scrollX = TRUE,    # Enable horizontal scrolling\n      scroller = TRUE, \n      orderMulti = TRUE,  # Enable multiple column sorting\n      initComplete = JS(\n        \"function(settings, json) {\",\n        \"$('.dataTables_wrapper').css('font-size', '12px');\",  # Adjust font size here\n        \"}\"\n      )\n    ),\n    caption = htmltools::tags$caption(\n      style = 'caption-side: bottom; text-align: left; font-size: 12px; color: #777; font-style: italic;',\n      'Note: Hold Shift to sort by multiple columns'\n    )\n  )\n```\n\n## Compare regional with estimated demand from country data\n\nRegional Europe and regional EU (Area column), estimated Europe (sum of countries from Ember region column), estimated EU (sum of countries from EU column) and BFF Europe (sum of BFF countries)\n\n```{r}\ndemandEUEuropeRegional <- filter(dfdown, Area %in% c('EU', 'Europe'), \n                         Variable %in% 'Demand') %>% \n  mutate(set = ifelse(Area == 'EU', \n                      'EU - regional', \n                      'Europe - regional'))\n\n## 39 countries\ndemandEuropeEstimated <- filter(dfdown0, `Ember region` == 'Europe', \n                         Variable %in% 'Demand', \n                         ) %>% \n  group_by(Date) %>% \n  summarize(set = 'Europe - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandEUEstimated <- filter(dfdown0, EU == 1, \n                         Variable %in% 'Demand') %>% \n  group_by(Date) %>% \n  summarize(set = 'EU - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandBFF <- filter(dfdown, !Area %in% c('EU', 'Europe'), \n                         Variable %in% 'Demand') %>% \n  group_by(Date) %>% \n  summarize(set = 'BFF Europe - estimated',\n            Value = sum(Value, na.rm = TRUE))\n\ndemandComp <- bind_rows(demandEUEstimated, demandEuropeEstimated, demandEUEuropeRegional, demandBFF) %>% \n  mutate(set = factor(set, levels=c('Europe - regional', \n                                    'Europe - estimated', \n                                    'BFF Europe - estimated',\n                                    'EU - regional',\n                                    'EU - estimated'))) \n\nq1 <- demandComp %>%\n  ggplot(aes(x = Date, y = Value, color = set)) +\n  geom_line() +\n  geom_point() +\n  theme_classic() +\n  labs(y = 'Demand TWh since 2015', x = NULL, colour = NULL) \n\nq2 <- filter(demandComp, Date >= \"2024-01-01\") %>%\n  ggplot(aes(x = Date, y = Value, color = set)) +\n  geom_line() +\n  geom_point() +\n  theme_classic() +\n  labs(y = 'Demand TWh in 2024', x = NULL, colour = NULL) \n\n(q1 + q2 & theme(legend.position = \"bottom\")) + \n  plot_layout(guides = \"collect\", widths = c(2, 1))  \n\ndfdown1 <- dfdown %>%\n  filter(Date >= \"2017-01-01\")\n```\n\nBetter to use EU demand estimates to bound the model and only from 2017 onwards. Shouldn't use Regional Europe to adjust non-EU countries since this includes Russia, although could remove the Russia data from Europe regional and make the adjustment, but given there is no net imports for Regional Europe, it might make more sense to use non-EU countries data without adjustment.\n\n## Identify the months and countries missing data for the last 12 months\n\n```{r}\nmissing_data <- dfdown1 %>%\n  group_by(Area, Date, Variable) %>%\n  summarize(EU = unique(EU),\n            missing = any(is.na(Value)), .groups = 'drop') \n\nlength(unique(missing_data$Date)) #months with available data to project since 2017\nmissing_lastYear <- missing_data %>%\n  filter(Date > today() - months(13)) %>% # the current month won't have data\n  group_by(Area, Variable) %>%\n  summarise(EU = unique(EU),\n            months_with_data = sum(!missing), .groups = 'drop') %>%\n  pivot_wider(names_from = Variable, values_from = months_with_data, values_fill = 0) %>% \n  relocate(c(Demand,`Net Imports`, `Total Generation`), .before = Bioenergy) %>% \n  arrange(desc(EU), Area)\n\nmissing_lastYear %>%  ##to get an overview for which countries and fuels there is data since June 2023 (not excluding zeros)\n  mutate_if(is.numeric, round, 3) %>% \n  datatable(\n    filter = \"top\",  \n    rownames = FALSE, \n    extensions = 'Scroller', \n    options = list(autoWidth = TRUE,\n                   deferRender = TRUE,\n                   scrollY = 300,\n                   scrollX = TRUE,    # Enable horizontal scrolling\n                   scroller = TRUE, \n                   initComplete = JS(\n                     \"function(settings, json) {\",\n                     \"$('.dataTables_wrapper').css('font-size', '10px');\",  # Adjust font size here\n                     \"}\")))\n```\n\nBetter to use demand to initially identify which countries and months to do the predictions\n\n# EU countries adjustments with predictions when needed\n\n## Demand adjustment to Regional EU\n\n### Compare against Regional EU demand\n\n```{r}\n#| fig-height: 6    # Set default figure height for all chunks\n#| fig-width: 12  \n\n# Aggregate the country-level Demand data for each month\ndemand_EU_Estimated <- dfdown1 %>%\n  filter(Variable == \"Demand\", EU == 1) %>%\n  group_by(Date) %>%\n  summarize(EU_Estimated = sum(Value, na.rm = TRUE), .groups = 'drop')\n\n# Extract the EU Demand data for the same months\ndemand_EU_Regional <- dfdown1 %>%\n  filter(Area == \"EU\", Variable == \"Demand\", Date %in% demand_EU_Estimated$Date) %>%\n  select(Date, EU_Regional = Value)\n\n# Merge the country-aggregated and EU data for comparison\ncompEU <- left_join(demand_EU_Estimated, demand_EU_Regional, by = \"Date\") %>%\n  mutate(difference = EU_Regional - EU_Estimated)\n\n# View the comparison to see any discrepancies\n\nq3 <- ggplot(compEU, aes(x = EU_Estimated, y = EU_Regional)) +\n  geom_abline() +\n  geom_smooth(method = 'lm') +\n  geom_point() +\n  theme_classic() + \n  scale_y_continuous(expand = c(0.01 ,0)) +\n  scale_x_continuous(expand = c(0.01 ,0))\n\nq4 <- ggplot(compEU, aes(x = Date, y = difference)) +\n  geom_col() +\n  labs(y = \"Difference between regional and estimated EU demand\", x = NULL) +\n  scale_x_date(expand = c(0.01 ,0), date_breaks = \"1 year\", date_labels = \"%Y %b\") +\n  scale_y_continuous(expand = c(0.01 ,0)) +\n  theme_classic()\n\nq3 + q4\n```\n\nThe estimated EU values from adding up all countries seem to be highly correlated enough but the difference seem to be higher prior to 2019.\n\n### Predict demand missing data using ARIMA\n\n```{r}\ndemand_filtered <- dfdown1 %>%\n  filter(Date >= \"2019-01-01\", \n         Variable == \"Demand\", \n         EU == 1)\n\n# Create a complete date sequence from min to max months used for all countries\nall_dates <- seq(from = min(demand_filtered$Date), to = max(demand_filtered$Date), by = \"month\")\n\n# Generate a complete dataset with all Areas, all Dates and all variables\ncomplete_data <- expand_grid(Area = unique(demand_filtered$Area), \n                             EU = 1,\n                             Date = all_dates, \n                             Variable = unique(dfdown1$Variable))\n\n# Filter to just demand data and left join with the existing demand_filtered to identify missing entries\ndemand_complete <- complete_data %>%\n  filter(Variable %in% 'Demand') %>% \n  left_join(demand_filtered, by = c(\"EU\", \"Area\", \"Date\", \"Variable\"))  %>% # Mark rows as missing where the Value is NA\n  mutate(missing = ifelse(is.na(Value), TRUE, FALSE))\n\ndemand_complete %>%\n  group_by(Area) %>%\n  summarize(missing_months = sum(missing), \n            total_months = n(), .groups = 'drop') %>% \n  filter(missing_months != 0)\n\n\n# Function to fit ARIMA and predict missing data - needs to include the rows with the missing data to predict\npredict_missing_data <- function(data) {\n  data <- data %>% \n    mutate(predicted = ifelse(is.na(Value), TRUE, FALSE)) # Create a new column to flag predicted values\n  \n  if(any(is.na(data$Value))) {\n    # Fit ARIMA model to non-missing data\n    fit <- auto.arima(data$Value, seasonal = TRUE)\n    \n    # Predict missing values\n    missing_index <- which(is.na(data$Value))\n    data$Value[missing_index] <- forecast(fit, h = length(missing_index))$mean\n  }\n  \n  return(data)\n}\n\n# Apply the function to each country's Demand data\npredicted_data <- demand_complete %>%\n  group_by(Area) %>%\n  nest() %>%\n  mutate(data = map(data, predict_missing_data)) %>%\n  unnest(data) %>% \n  rename(pred_Value = Value)\n\nfilter(predicted_data, predicted == TRUE)\n```\n\n### Adjust Predictions to Match EU Totals\n\n```{r}\n#| fig-height: 6    # Set default figure height for all chunks\n#| fig-width: 8 \n \n# Aggregate predicted data at the EU level\npredicted_EU_demand <- predicted_data %>%\n  group_by(Date) %>%\n  summarize(predicted_EU = sum(pred_Value, na.rm = TRUE), .groups = 'drop')\n\n# Compare predicted EU data with EU Regional data\ncompEUpred <- predicted_EU_demand %>%\n  left_join(demand_EU_Regional, by = \"Date\") %>%\n  mutate(adjustment_factor = EU_Regional / predicted_EU)\n\n# Apply the EU-wide adjustment to country-level predictions\npredAdjusted_data <- predicted_data %>%\n  left_join(select(compEUpred, Date, adjustment_factor), by = \"Date\") %>%\n  mutate(PredAdjusted_Value = pred_Value * adjustment_factor) %>%\n  select(-adjustment_factor)\n\nggplot(predAdjusted_data, aes(x = PredAdjusted_Value, \n                                       y = pred_Value)) +\n  geom_abline() +\n  geom_smooth(method = 'lm') +\n  geom_point(aes(size = predicted, shape = predicted)) +\n  theme_classic() + \n  scale_y_continuous(expand = c(0.01 ,0)) +\n  scale_x_continuous(expand = c(0.01 ,0)) +\n  scale_shape_manual(values = c(20,21)) +\n  labs(y = \"Demand with the values that were predicted\", \n       x = \"Demand with adjusted values given Regional EU demand\",\n       subtitle = paste(table(predAdjusted_data$predicted)[2], 'values were predicted'))\n\npaste0(\"Counts of values different between EU regional and adjusted estimated > 0.00001: \",\n       predAdjusted_data %>%\n  group_by(Date) %>%\n  summarize(PredAdjusted_EU = sum(PredAdjusted_Value, na.rm = TRUE), .groups = 'drop') %>%\n  left_join(compEUpred, by = 'Date') %>%\n  tally(abs((EU_Regional-PredAdjusted_EU)) > 0.00001) %>% \n    pull(n))\n\n```\n\nNo value has a difference bigger than 0.00001 between EU regional values and the adjusted and predicted added up EU estimates.\n\n## Net imports predictions to calculate adjusted total generation given adjusted to EU regional demand\n\n```{r}\n## get the complete rows with the fuel values\ncomplete_data2 <- left_join(complete_data, dfdown1) \n\n# Predict Net Imports using the ARIMA function\nnet_imports_data <- complete_data2 %>% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable == \"Net Imports\")  %>%\n  group_by(Area) %>%\n  nest() %>%\n  mutate(data = map(data, predict_missing_data)) %>%\n  unnest(data) %>% \n  rename(pred_Imports = Value)\n\n# Predict Total Generation using the defined ARIMA function to keep if needed eventually\ntotal_generation_data <- complete_data2 %>% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable == \"Total Generation\")  %>%\n  group_by(Area) %>%\n  nest() %>%\n  mutate(data = map(data, predict_missing_data)) %>%\n  unnest(data) %>% \n  rename(pred_Total = Value)\n\n# Get the adjusted Total generation from predicted Imports and predicted Demand\npred_missing_ImpTotal <- filter(predAdjusted_data, predicted == TRUE) %>%  \n  left_join(select(net_imports_data, Area, Date, pred_Imports)) %>% \n  left_join(select(total_generation_data, Area, Date, pred_Total)) %>% \n  rename(PredAdjusted_Demand = PredAdjusted_Value) %>% \n  mutate(adjusted_Total = PredAdjusted_Demand - pred_Imports)\npred_missing_ImpTotal\n```\n\n## Fuels adjustment to EU regional\n\nEstimate adjusted fuels by taking a adjusted total generation from the EU regional adjusted demand and the per country/fuel net imports.\n\n### Prediction and adjustment for missing countries/months per fuel + country + month\n\n```{r}\n# Predict per fuel and adjust based on adjusted total\nfuel_types <- filter(complete_data2, !Variable %in% \n                       c(\"Demand\",\"Net Imports\", \"Total Generation\")) %>% \n  pull(Variable) %>% \n  unique()\n\nmissingCountries_fuel_data <- complete_data2 %>% \n  filter(Area %in% unique(pull(filter(predicted_data, predicted == TRUE), Area)), \n         Variable %in% fuel_types)  \n\nfinal_fuel_predictions <- list()\n# Loop through each country with missing data\nfor (country in unique(pred_missing_ImpTotal$Area)) {\n  \n  missingDates <- filter(predicted_data, predicted == TRUE, Area == country) %>% \n    pull(Date)\n  \n  # Filter for the specific country\n  country_data <- missingCountries_fuel_data %>% \n    filter(Area == country) %>%\n    ## deal with the fuels that are missing in historical data, consider them zeros. If not doing this it will predict values for month for which there is data\n    mutate(Value = case_when(!Date %in% missingDates & is.na(Value) ~ 0,\n                             TRUE~Value)) \n  \n  # Initialize an empty list to store fuel predictions for this country\n  country_fuel_predictions <- list()\n  ## Loop through each fuel type\n  for (fuel in fuel_types) {\n    \n    # Predict fuel contribution using the defined ARIMA function\n    fuel_data <- country_data %>% \n      filter(Variable == fuel)\n    \n    predicted_fuel <- predict_missing_data(fuel_data) %>% \n      filter(predicted == TRUE)\n    \n    # Store the fuel predictions\n    country_fuel_predictions[[fuel]] <- predicted_fuel\n  }\n  \n  # Combine all the fuel predictions for this country\n  country_fuels_df <- bind_rows(country_fuel_predictions)\n  \n  # Check if the sum of predicted fuels matches the adjusted Total Generation\n  sum_predicted_fuels <- country_fuels_df %>% \n    group_by(Area, Date) %>%\n    summarize(sum_fuels = sum(Value, na.rm = TRUE)) %>% \n    left_join(select(pred_missing_ImpTotal, Area, Date, adjusted_Total)) %>%\n    mutate(adjustment_factor = adjusted_Total / sum_fuels)\n  \n  # Store the adjusted fuel predictions for each country\n  final_fuel_predictions[[country]] <- country_fuels_df %>%\n    left_join(sum_predicted_fuels) %>%\n    mutate(adjusted_valueFuel = Value * adjustment_factor) %>%\n    select(Area, Date, Variable, Value, adjusted_valueFuel)\n}\n\n# Combine all missing countries' fuel predictions \nmissing_fuel_predictions_df <- bind_rows(final_fuel_predictions)\n\nmissingFinal <- select(pred_missing_ImpTotal, -Variable, -`Country code`, -missing) %>% \n  rename(`Net Imports` = pred_Imports, `Total Generation` = pred_Total,\n         Demand = pred_Value, adjusted_Demand = PredAdjusted_Demand ) %>% \n  left_join(missing_fuel_predictions_df)\n```\n\n### Adjustment of non missing countries/months\n\n```{r}\n# Create a DataFrame for fuels without the missing data\nnonmissing_fuel <- complete_data2 %>%\n  filter(Variable %in% fuel_types) %>%\n  select(Area, EU, Date, Variable, Value) %>% \n  replace_na(list(Value = 0)) ### assume missing fuels are just 0s\n\n# Left Join Net Imports, Total Generation, and Demand per fuel/country/date and get adjusted Total for non missing\nfuel_adjustment_data <- complete_data2 %>%\n    filter(!Variable %in% fuel_types) %>%\n    select(Area, EU, Date, Variable, Value) %>% \n  pivot_wider(names_from = Variable, values_from = Value) %>% \n  left_join(nonmissing_fuel) %>% \n  left_join(select(predAdjusted_data, Area, Date, predicted, PredAdjusted_Value)) %>% \n  rename(PredAdjusted_Demand = PredAdjusted_Value) %>%\n  mutate(adjusted_Total = PredAdjusted_Demand - `Net Imports`) %>%\n    filter(predicted == FALSE)\n\n# Apply Adjustment Factor to Fuels for non missing\nadjusted_fuel_data <- fuel_adjustment_data  %>% \n  group_by(Area, Date) %>%\n  mutate(sum_fuels = sum(Value, na.rm = TRUE),\n         adjustment_factor = adjusted_Total / sum_fuels,\n         adjusted_valueFuel = Value * adjustment_factor) %>%\n  select(Area, Date, Variable, adjusted_valueFuel)\n\n# clean data for both missing and non missing as well demand/total/net imports and adjusted\nfinalDataEU <- left_join(fuel_adjustment_data, adjusted_fuel_data) %>% \n  rename(adjusted_Demand = PredAdjusted_Demand) %>% \n  bind_rows(missingFinal) %>% \n  relocate(c(EU, predicted,`Net Imports`, `Total Generation`, adjusted_Total, Demand, adjusted_Demand), .before = Variable) %>% \n  rename(Fuel = Variable, Fuel_value = Value, AdjustedFuel_value = adjusted_valueFuel)\n\n```\n\n------------------------------------------------------------------------\n\n```{r}\n#| echo: false\nlibrary(plotly)\nlibrary(crosstalk)\n\nfinalDataEU$predicted_Label <- ifelse(finalDataEU$predicted, \"Predicted\", \"Actual value\")\n\n# Create a SharedData object for linking the data with filters\nshared_finalData <- SharedData$new(finalDataEU)\n\n# Arrange the filters side by side using bscols\nbscols(\n  widths = c(3,NA),  # Adjust widths to fit your layout needs\n  \n  list(\n  filter_select(\"fuel\", \"Select Fuel:\", shared_finalData, ~Fuel),\n  filter_select(\"area\", \"Select Country:\", shared_finalData, ~Area)\n  ),\n  \n  # Create the Plotly scatter plot using color to differentiate 'predicted'\n  plot_ly(shared_finalData) %>%\n    add_trace(\n      x = ~AdjustedFuel_value,\n      y = ~Fuel_value,\n      color = ~predicted_Label,\n      colors = c('black', 'red'),\n      type = 'scatter',\n      mode = 'markers',\n      text = ~paste(\n        \"Date:\", Date,\n        \"<br>Actual generation:\", round(Fuel_value, 2),\n        \"<br>Adjusted generation:\", round(AdjustedFuel_value,2),\n        \"<br>Predicted value:\", predicted\n      ),\n      hoverinfo = 'text'  # Use the text provided in `text` for the tooltip\n    )  %>%\n    layout(\n      \n      title = \"Visualize how adjusted values compare to actual data per country and fuel\",\n      xaxis = list(\n        title = \"Adjusted fuel values given Regional EU\",\n        autorange = TRUE\n      ),\n      yaxis = list(\n        title = \"Actual fuel values\",\n        autorange = TRUE\n      )\n    )\n)\n```\n\n# Non-EU countries predictions\n\n-   Not doing adjustments based on regional data for these countries\n\n-   Moldova only has data starting in 2020 while Kosovo only has data starting in 2022, so it would be better to make predictions based on each country minimum month\n\n-   Exclude Ukraine from making predictions since data only goes until Sept 2022\n\n-   Predict data for fuels and net imports for each country then get demand and total generation from predicted data.\n\n```{r}\nnonEU_filtered <- dfdown1 %>%\n  filter(Date >= \"2019-01-01\",\n         !Area %in% 'Ukraine',\n         EU == 0)\n\n# get missing months per country based on Demand data\nnonEU_filtered_demand <- nonEU_filtered %>%\n  filter(Variable %in% \"Demand\") %>% \n  select(Area, Date, NotMissing = Variable)\n\n# Create a complete date sequence for the same date range as the EU dataset\nall_dates <- seq(from = min(finalDataEU$Date), to = max(finalDataEU$Date), by = \"month\")\n\n# need to exclude months of the 2 countries with minimum date after 2019\nset2 <- filter(monthsOverview, `Minimum Month` > min(nonEU_filtered$Date)) %>% \n  select(Area, Date = `Minimum Month`) %>% \n  mutate(remove = 1)\nset2\n\n# Generate a complete dataset with all Areas, all Dates and all variables\ncomplete_dataNonEU <- expand_grid(Area = unique(nonEU_filtered$Area), \n                             EU = 0,\n                             Date = all_dates, \n                             Variable = unique(nonEU_filtered$Variable))   %>%\n  left_join(set2, by = \"Area\")  %>%\n  filter(!(Date.y > Date.x) | is.na(remove) ) %>%  # exclude rows which Date is previous to minimum date available for a given country\n  select(-remove, -Date.y, Date = Date.x) %>% \n  left_join(dfdown1) %>% \n  left_join(nonEU_filtered_demand) %>% ### to deal with the values that are missing in historical data, consider them zeros. If not doing this it will predict values for month for which there is data\n  mutate(Value = ifelse(is.na(Value) & !is.na(NotMissing), 0, Value)) %>% \n  select(-NotMissing) \n\n## nonEU countries predicting data:\nmissingMonths <- filter(complete_dataNonEU, is.na(Value)) %>% \n  select( Area, Date) %>% \n  distinct()\n\nmissingMonths \n\n# Predict per fuel and for net imports\nfuelImp_types <- c(fuel_types, \"Net Imports\")\n\nnonEU_predictions <- list()\n# Loop through each country with missing data\nfor (country in unique(missingMonths$Area)) {\n  \n  # Filter for the specific country\n  country_data <- complete_dataNonEU %>% \n    filter(Area == country,\n           !Variable %in% c(\"Demand\", \"Total Generation\")) \n  \n  # Initialize an empty list to store fuel predictions for this country\n  country_fuel_predictions <- list()\n  ## Loop through each fuel type\n  for (fuel in fuelImp_types) {\n    \n    # Predict fuel contribution using the defined ARIMA function\n    fuel_data <- country_data %>% \n      filter(Variable == fuel)\n    \n    predicted_fuel <- predict_missing_data(fuel_data) %>% \n      filter(predicted == TRUE)\n    \n    # Store the fuel predictions\n    country_fuel_predictions[[fuel]] <- predicted_fuel\n  }\n  \n  # Combine all the fuel predictions for this country\n  country_fuels_df <- bind_rows(country_fuel_predictions)\n  \n  ## get total generation and demand from predicted data\n  Total_predicted_fuels <- country_fuels_df %>% \n    filter(!Variable %in% \"Net Imports\") %>% \n    group_by(Area, Date) %>%\n    summarize(`Total Generation` = sum(Value, na.rm = TRUE)) \n  \n  Demand_predicted_fuels <- country_fuels_df %>% \n    filter(Variable %in% \"Net Imports\") %>% \n    left_join(Total_predicted_fuels, by = join_by(Area, Date)) %>% \n    mutate(Demand = `Total Generation` + Value) %>% \n    select(Area, Date, `Net Imports` = Value, `Total Generation`, Demand)\n  \n  # Store the adjusted fuel predictions for each country\n  nonEU_predictions[[country]] <- country_fuels_df %>%\n    filter(!Variable %in% \"Net Imports\") %>% \n    left_join(Demand_predicted_fuels, by = join_by(Area, Date)) \n}\n\n# Combine all missing countries' fuel predictions \nnonEU_predictions_df <- bind_rows(nonEU_predictions) %>% \n  select(-`Country code`) \n\nFinal_nonEUComplete <- filter(complete_dataNonEU, !is.na(Value)) %>%\n  select(-`Country code`) %>% \n  pivot_wider(names_from = Variable, values_from = Value) %>% \n  pivot_longer(cols = !!fuel_types, names_to = 'Variable', values_to = 'Value') %>% \n  mutate(predicted = FALSE) %>% \n  bind_rows(nonEU_predictions_df) %>% \n  rename(Fuel = 'Variable', Fuel_value = 'Value')\n```\n\n# Bringing together EU and nonEU data\n\n```{r}\n# clean data for both missing and non missing as well demand/total/net imports and adjusted, for EU and nonEU countries (not with adjusted values)\nfinalData <- bind_rows(finalDataEU[-13], Final_nonEUComplete)\n```\n\n```{r}\n#| echo: false\n#| warning: false\n#| message: false\n\nfinalData %>%\n  mutate_if(is.numeric, round, 3) %>% \n      datatable(\n    filter = \"top\",  \n    rownames = FALSE, \n    extensions = 'Scroller', \n    options = list(\n      autoWidth = TRUE,\n      deferRender = TRUE,\n      scrollY = 400,\n      scrollX = TRUE,    # Enable horizontal scrolling\n      scroller = TRUE, \n      orderMulti = TRUE,  # Enable multiple column sorting\n      initComplete = JS(\n        \"function(settings, json) {\",\n        \"$('.dataTables_wrapper').css('font-size', '10px');\",  # Adjust font size here\n        \"}\"\n      )\n    ),\n    caption = htmltools::tags$caption(\n      style = 'caption-side: bottom; text-align: left; font-size: 10px; color: #777; font-style: italic;',\n      'Note: Hold Shift to sort by multiple columns'\n    )\n  )\n```\n\n------------------------------------------------------------------------\n\nVisualizing fuel per country (with predicted but not adjusted data)\n\n```{r}\n#| echo: false\n#| warning: false\n#| message: false\n\nlibrary(jsonlite)\n# Prepare all data\nall_data <- finalData %>%\n  select(Area, Date, Fuel, Fuel_value)\n\n# Get unique areas for the dropdown\nareas <- unique(all_data$Area)\n\n# Convert to JSON for use in Observable\nojs_define(all_data_json = toJSON(all_data))\nojs_define(areas_json = toJSON(areas))\n```\n\n```{ojs}\n//| echo: false\n\n// Parse the JSON data\ndata = JSON.parse(all_data_json)\nareas = JSON.parse(areas_json)\n\n// Create a dropdown for area selection\nviewof selectedArea = Inputs.select(areas, {label: \"Select Area\", value: areas[0]})\n\n// Define fuel types\nfuels = [\"Solar\", \"Wind\",\"Other Renewables\", \"Coal\", \"Gas\",  \"Other Fossil\", \"Hydro\",\"Bioenergy\",  \"Nuclear\"]\n\n// Function to filter and prepare data\nfunction prepareData(area, fuel) {\n  return data\n    .filter(d => d.Area === area && d.Fuel === fuel)\n    .map(d => ({...d, Year: d.Date.substring(0, 4)}));\n}\n\n// Function to create a single plot\nfunction createPlot(fuel) {\n  const plotData = prepareData(selectedArea, fuel);\n  \n  // Check for empty data or data with only zero values\n  if (plotData.length === 0 || plotData.every(d => d.Fuel_value === 0)) {\n    return html`<div style=\"width: 200px; height: 200px; display: flex; justify-content: right; align-items: center; \">\n      <p></p>\n    </div>`;\n  }\n  \n  return Plot.plot({\n      style: {\n      fontSize: \"12px\",\n      fontFamily: \"OpenSans, sans-serif\"\n    },\n    y: {grid: true, label: \"\", \n    tickSize: 0\n      },\n    x: {\n      label: \"\",\n      tickFormat: d => d.endsWith(\"-01-01\") ? d.substring(0, 4) : \"\",\n      ticks: plotData\n        .filter(d => d.Date.endsWith(\"-01-01\"))\n        .map(d => d.Date),\n    },\n    marks: [\n      Plot.barY(plotData, {\n        x: \"Date\", \n        y: \"Fuel_value\", \n        fill: \"steelblue\",\n         tip: true,\n        title: d => `Date: ${d.Date}\\nGeneration: ${d.Fuel_value.toFixed(2)} TWh`\n      })\n    ],\n    width: 300,\n    height: 300,\n    title: fuel  // Set the fuel type as the title\n  })\n}\n\n// Create a 3x3 grid of plots\nhtml`<div style=\"display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px;\">\n  ${fuels.map(fuel => html`<div>\n    <h3 style=\"text-align: center; margin-bottom: 1px;\">${fuel}</h3>\n    ${createPlot(fuel)}\n  </div>`)}\n</div>`\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":8,"fig-height":6,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"fig-align":"center","progress":true,"verbose":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-in-header":[{"text":"<script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>\n"}],"self-contained":true,"toc":true,"number-sections":false,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","toc-float":{"collapsed":false,"smooth-scroll":true},"theme":"default","title":"Optimization of Ember Electricity Generation Data with ARIMA Model and Regional EU Adjustments","author":"Ana Afonso Silva","date":"`r Sys.Date()`"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}